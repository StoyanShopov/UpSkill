{"ast":null,"code":"import didYouMean from '../../jsutils/didYouMean';\nimport suggestionList from '../../jsutils/suggestionList';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { isObjectType, isInterfaceType, isAbstractType } from '../../type/definition';\nexport function undefinedFieldMessage(fieldName, type, suggestedTypeNames, suggestedFieldNames) {\n  var quotedTypeNames = suggestedTypeNames.map(function (x) {\n    return \"\\\"\".concat(x, \"\\\"\");\n  });\n  var quotedFieldNames = suggestedFieldNames.map(function (x) {\n    return \"\\\"\".concat(x, \"\\\"\");\n  });\n  return \"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type, \"\\\".\") + (didYouMean('to use an inline fragment on', quotedTypeNames) || didYouMean(quotedFieldNames));\n}\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\n\nexport function FieldsOnCorrectType(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n\n      if (type) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestedTypeNames = getSuggestedTypeNames(schema, type, fieldName); // If there are no suggested types, then perhaps this was a typo?\n\n          var suggestedFieldNames = suggestedTypeNames.length !== 0 ? [] : getSuggestedFieldNames(schema, type, fieldName); // Report an error, including helpful suggestions.\n\n          context.reportError(new GraphQLError(undefinedFieldMessage(fieldName, type.name, suggestedTypeNames, suggestedFieldNames), node));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest\n * them, sorted by how often the type is referenced, starting with Interfaces.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (isAbstractType(type)) {\n    var suggestedObjectTypes = [];\n    var interfaceUsageCount = Object.create(null);\n\n    for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++) {\n      var possibleType = _schema$getPossibleTy2[_i2];\n\n      if (!possibleType.getFields()[fieldName]) {\n        continue;\n      } // This object type defines this field.\n\n\n      suggestedObjectTypes.push(possibleType.name);\n\n      for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {\n        var possibleInterface = _possibleType$getInte2[_i4];\n\n        if (!possibleInterface.getFields()[fieldName]) {\n          continue;\n        } // This interface type defines this field.\n\n\n        interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;\n      }\n    } // Suggest interface types based on how common they are.\n\n\n    var suggestedInterfaceTypes = Object.keys(interfaceUsageCount).sort(function (a, b) {\n      return interfaceUsageCount[b] - interfaceUsageCount[a];\n    }); // Suggest both interface and object types.\n\n    return suggestedInterfaceTypes.concat(suggestedObjectTypes);\n  } // Otherwise, must be an Object type, which does not have possible fields.\n\n\n  return [];\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(schema, type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}","map":{"version":3,"sources":["H:/Programming Repositories/Titans/Web/UpSkill.Web/ClientApp/node_modules/graphql/validation/rules/FieldsOnCorrectType.mjs"],"names":["didYouMean","suggestionList","GraphQLError","isObjectType","isInterfaceType","isAbstractType","undefinedFieldMessage","fieldName","type","suggestedTypeNames","suggestedFieldNames","quotedTypeNames","map","x","concat","quotedFieldNames","FieldsOnCorrectType","context","Field","node","getParentType","fieldDef","getFieldDef","schema","getSchema","name","value","getSuggestedTypeNames","length","getSuggestedFieldNames","reportError","suggestedObjectTypes","interfaceUsageCount","Object","create","_i2","_schema$getPossibleTy2","getPossibleTypes","possibleType","getFields","push","_i4","_possibleType$getInte2","getInterfaces","possibleInterface","suggestedInterfaceTypes","keys","sort","a","b","possibleFieldNames"],"mappings":"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","sourcesContent":["import didYouMean from '../../jsutils/didYouMean';\nimport suggestionList from '../../jsutils/suggestionList';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { isObjectType, isInterfaceType, isAbstractType } from '../../type/definition';\nexport function undefinedFieldMessage(fieldName, type, suggestedTypeNames, suggestedFieldNames) {\n  var quotedTypeNames = suggestedTypeNames.map(function (x) {\n    return \"\\\"\".concat(x, \"\\\"\");\n  });\n  var quotedFieldNames = suggestedFieldNames.map(function (x) {\n    return \"\\\"\".concat(x, \"\\\"\");\n  });\n  return \"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type, \"\\\".\") + (didYouMean('to use an inline fragment on', quotedTypeNames) || didYouMean(quotedFieldNames));\n}\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\n\nexport function FieldsOnCorrectType(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n\n      if (type) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestedTypeNames = getSuggestedTypeNames(schema, type, fieldName); // If there are no suggested types, then perhaps this was a typo?\n\n          var suggestedFieldNames = suggestedTypeNames.length !== 0 ? [] : getSuggestedFieldNames(schema, type, fieldName); // Report an error, including helpful suggestions.\n\n          context.reportError(new GraphQLError(undefinedFieldMessage(fieldName, type.name, suggestedTypeNames, suggestedFieldNames), node));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest\n * them, sorted by how often the type is referenced, starting with Interfaces.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (isAbstractType(type)) {\n    var suggestedObjectTypes = [];\n    var interfaceUsageCount = Object.create(null);\n\n    for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++) {\n      var possibleType = _schema$getPossibleTy2[_i2];\n\n      if (!possibleType.getFields()[fieldName]) {\n        continue;\n      } // This object type defines this field.\n\n\n      suggestedObjectTypes.push(possibleType.name);\n\n      for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {\n        var possibleInterface = _possibleType$getInte2[_i4];\n\n        if (!possibleInterface.getFields()[fieldName]) {\n          continue;\n        } // This interface type defines this field.\n\n\n        interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;\n      }\n    } // Suggest interface types based on how common they are.\n\n\n    var suggestedInterfaceTypes = Object.keys(interfaceUsageCount).sort(function (a, b) {\n      return interfaceUsageCount[b] - interfaceUsageCount[a];\n    }); // Suggest both interface and object types.\n\n    return suggestedInterfaceTypes.concat(suggestedObjectTypes);\n  } // Otherwise, must be an Object type, which does not have possible fields.\n\n\n  return [];\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(schema, type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}\n"]},"metadata":{},"sourceType":"module"}