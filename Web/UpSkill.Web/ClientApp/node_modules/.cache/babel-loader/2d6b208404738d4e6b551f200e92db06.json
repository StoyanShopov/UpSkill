{"ast":null,"code":"'use strict';\n\nconst escapeStringRegexp = require('escape-string-regexp');\n\nconst regexpCache = new Map();\n\nfunction makeRegexp(pattern, options) {\n  options = {\n    caseSensitive: false,\n    ...options\n  };\n  const cacheKey = pattern + JSON.stringify(options);\n\n  if (regexpCache.has(cacheKey)) {\n    return regexpCache.get(cacheKey);\n  }\n\n  const negated = pattern[0] === '!';\n\n  if (negated) {\n    pattern = pattern.slice(1);\n  }\n\n  pattern = escapeStringRegexp(pattern).replace(/\\\\\\*/g, '[\\\\s\\\\S]*');\n  const regexp = new RegExp(`^${pattern}$`, options.caseSensitive ? '' : 'i');\n  regexp.negated = negated;\n  regexpCache.set(cacheKey, regexp);\n  return regexp;\n}\n\nmodule.exports = (inputs, patterns, options) => {\n  if (!(Array.isArray(inputs) && Array.isArray(patterns))) {\n    throw new TypeError(`Expected two arrays, got ${typeof inputs} ${typeof patterns}`);\n  }\n\n  if (patterns.length === 0) {\n    return inputs;\n  }\n\n  const isFirstPatternNegated = patterns[0][0] === '!';\n  patterns = patterns.map(pattern => makeRegexp(pattern, options));\n  const result = [];\n\n  for (const input of inputs) {\n    // If first pattern is negated we include everything to match user expectation.\n    let matches = isFirstPatternNegated;\n\n    for (const pattern of patterns) {\n      if (pattern.test(input)) {\n        matches = !pattern.negated;\n      }\n    }\n\n    if (matches) {\n      result.push(input);\n    }\n  }\n\n  return result;\n};\n\nmodule.exports.isMatch = (input, pattern, options) => {\n  const inputArray = Array.isArray(input) ? input : [input];\n  const patternArray = Array.isArray(pattern) ? pattern : [pattern];\n  return inputArray.some(input => {\n    return patternArray.every(pattern => {\n      const regexp = makeRegexp(pattern, options);\n      const matches = regexp.test(input);\n      return regexp.negated ? !matches : matches;\n    });\n  });\n};","map":{"version":3,"sources":["H:/Programming Repositories/Titans/Web/UpSkill.Web/ClientApp/node_modules/matcher/index.js"],"names":["escapeStringRegexp","require","regexpCache","Map","makeRegexp","pattern","options","caseSensitive","cacheKey","JSON","stringify","has","get","negated","slice","replace","regexp","RegExp","set","module","exports","inputs","patterns","Array","isArray","TypeError","length","isFirstPatternNegated","map","result","input","matches","test","push","isMatch","inputArray","patternArray","some","every"],"mappings":"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","sourcesContent":["'use strict';\nconst escapeStringRegexp = require('escape-string-regexp');\n\nconst regexpCache = new Map();\n\nfunction makeRegexp(pattern, options) {\n\toptions = {\n\t\tcaseSensitive: false,\n\t\t...options\n\t};\n\n\tconst cacheKey = pattern + JSON.stringify(options);\n\n\tif (regexpCache.has(cacheKey)) {\n\t\treturn regexpCache.get(cacheKey);\n\t}\n\n\tconst negated = pattern[0] === '!';\n\n\tif (negated) {\n\t\tpattern = pattern.slice(1);\n\t}\n\n\tpattern = escapeStringRegexp(pattern).replace(/\\\\\\*/g, '[\\\\s\\\\S]*');\n\n\tconst regexp = new RegExp(`^${pattern}$`, options.caseSensitive ? '' : 'i');\n\tregexp.negated = negated;\n\tregexpCache.set(cacheKey, regexp);\n\n\treturn regexp;\n}\n\nmodule.exports = (inputs, patterns, options) => {\n\tif (!(Array.isArray(inputs) && Array.isArray(patterns))) {\n\t\tthrow new TypeError(`Expected two arrays, got ${typeof inputs} ${typeof patterns}`);\n\t}\n\n\tif (patterns.length === 0) {\n\t\treturn inputs;\n\t}\n\n\tconst isFirstPatternNegated = patterns[0][0] === '!';\n\n\tpatterns = patterns.map(pattern => makeRegexp(pattern, options));\n\n\tconst result = [];\n\n\tfor (const input of inputs) {\n\t\t// If first pattern is negated we include everything to match user expectation.\n\t\tlet matches = isFirstPatternNegated;\n\n\t\tfor (const pattern of patterns) {\n\t\t\tif (pattern.test(input)) {\n\t\t\t\tmatches = !pattern.negated;\n\t\t\t}\n\t\t}\n\n\t\tif (matches) {\n\t\t\tresult.push(input);\n\t\t}\n\t}\n\n\treturn result;\n};\n\nmodule.exports.isMatch = (input, pattern, options) => {\n\tconst inputArray = Array.isArray(input) ? input : [input];\n\tconst patternArray = Array.isArray(pattern) ? pattern : [pattern];\n\n\treturn inputArray.some(input => {\n\t\treturn patternArray.every(pattern => {\n\t\t\tconst regexp = makeRegexp(pattern, options);\n\t\t\tconst matches = regexp.test(input);\n\t\t\treturn regexp.negated ? !matches : matches;\n\t\t});\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}