{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst path_1 = require(\"path\");\n\nconst sourceMapSupport = require(\"source-map-support\");\n\nconst ynModule = require(\"yn\");\n\nconst make_error_1 = require(\"make-error\");\n\nconst util = require(\"util\");\n/**\n * Registered `ts-node` instance information.\n */\n\n\nexports.REGISTER_INSTANCE = Symbol.for('ts-node.register.instance');\n/**\n * @internal\n */\n\nexports.INSPECT_CUSTOM = util.inspect.custom || 'inspect';\n/**\n * Wrapper around yn module that returns `undefined` instead of `null`.\n * This is implemented by yn v4, but we're staying on v3 to avoid v4's node 10 requirement.\n */\n\nfunction yn(value) {\n  var _a;\n\n  return (_a = ynModule(value)) !== null && _a !== void 0 ? _a : undefined;\n}\n/**\n * Debugging `ts-node`.\n */\n\n\nconst shouldDebug = yn(process.env.TS_NODE_DEBUG);\n/** @internal */\n\nexports.debug = shouldDebug ? (...args) => console.log(`[ts-node ${new Date().toISOString()}]`, ...args) : () => undefined;\nconst debugFn = shouldDebug ? (key, fn) => {\n  let i = 0;\n  return x => {\n    exports.debug(key, x, ++i);\n    return fn(x);\n  };\n} : (_, fn) => fn;\n/**\n * Export the current version.\n */\n\nexports.VERSION = require('../package.json').version;\n/**\n * Like `Object.assign`, but ignores `undefined` properties.\n */\n\nfunction assign(initialValue, ...sources) {\n  for (const source of sources) {\n    for (const key of Object.keys(source)) {\n      const value = source[key];\n      if (value !== undefined) initialValue[key] = value;\n    }\n  }\n\n  return initialValue;\n}\n/**\n * Default register options, including values specified via environment\n * variables.\n */\n\n\nexports.DEFAULTS = {\n  dir: process.env.TS_NODE_DIR,\n  emit: yn(process.env.TS_NODE_EMIT),\n  scope: yn(process.env.TS_NODE_SCOPE),\n  files: yn(process.env.TS_NODE_FILES),\n  pretty: yn(process.env.TS_NODE_PRETTY),\n  compiler: process.env.TS_NODE_COMPILER,\n  compilerOptions: parse(process.env.TS_NODE_COMPILER_OPTIONS),\n  ignore: split(process.env.TS_NODE_IGNORE),\n  project: process.env.TS_NODE_PROJECT,\n  skipProject: yn(process.env.TS_NODE_SKIP_PROJECT),\n  skipIgnore: yn(process.env.TS_NODE_SKIP_IGNORE),\n  preferTsExts: yn(process.env.TS_NODE_PREFER_TS_EXTS),\n  ignoreDiagnostics: split(process.env.TS_NODE_IGNORE_DIAGNOSTICS),\n  transpileOnly: yn(process.env.TS_NODE_TRANSPILE_ONLY),\n  typeCheck: yn(process.env.TS_NODE_TYPE_CHECK),\n  compilerHost: yn(process.env.TS_NODE_COMPILER_HOST),\n  logError: yn(process.env.TS_NODE_LOG_ERROR)\n};\n/**\n * Default TypeScript compiler options required by `ts-node`.\n */\n\nconst TS_NODE_COMPILER_OPTIONS = {\n  sourceMap: true,\n  inlineSourceMap: false,\n  inlineSources: true,\n  declaration: false,\n  noEmit: false,\n  outDir: '.ts-node'\n};\n/**\n * Split a string array of values.\n */\n\nfunction split(value) {\n  return typeof value === 'string' ? value.split(/ *, */g) : undefined;\n}\n\nexports.split = split;\n/**\n * Parse a string as JSON.\n */\n\nfunction parse(value) {\n  return typeof value === 'string' ? JSON.parse(value) : undefined;\n}\n\nexports.parse = parse;\n/**\n * Replace backslashes with forward slashes.\n */\n\nfunction normalizeSlashes(value) {\n  return value.replace(/\\\\/g, '/');\n}\n\nexports.normalizeSlashes = normalizeSlashes;\n/**\n * TypeScript diagnostics error.\n */\n\nclass TSError extends make_error_1.BaseError {\n  constructor(diagnosticText, diagnosticCodes) {\n    super(`тип Unable to compile TypeScript:\\n${diagnosticText}`);\n    this.diagnosticText = diagnosticText;\n    this.diagnosticCodes = diagnosticCodes;\n    this.name = 'TSError';\n  }\n  /**\n   * @internal\n   */\n\n\n  [exports.INSPECT_CUSTOM]() {\n    return this.diagnosticText;\n  }\n\n}\n\nexports.TSError = TSError;\n/**\n * Cached fs operation wrapper.\n */\n\nfunction cachedLookup(fn) {\n  const cache = new Map();\n  return arg => {\n    if (!cache.has(arg)) {\n      cache.set(arg, fn(arg));\n    }\n\n    return cache.get(arg);\n  };\n}\n/** @internal */\n\n\nfunction getExtensions(config) {\n  const tsExtensions = ['.ts'];\n  const jsExtensions = []; // Enable additional extensions when JSX or `allowJs` is enabled.\n\n  if (config.options.jsx) tsExtensions.push('.tsx');\n  if (config.options.allowJs) jsExtensions.push('.js');\n  if (config.options.jsx && config.options.allowJs) jsExtensions.push('.jsx');\n  return {\n    tsExtensions,\n    jsExtensions\n  };\n}\n\nexports.getExtensions = getExtensions;\n/**\n * Register TypeScript compiler instance onto node.js\n */\n\nfunction register(opts = {}) {\n  const originalJsHandler = require.extensions['.js']; // tslint:disable-line\n\n  const service = create(opts);\n  const {\n    tsExtensions,\n    jsExtensions\n  } = getExtensions(service.config);\n  const extensions = [...tsExtensions, ...jsExtensions]; // Expose registered instance globally.\n\n  process[exports.REGISTER_INSTANCE] = service; // Register the extensions.\n\n  registerExtensions(service.options.preferTsExts, extensions, service, originalJsHandler);\n  return service;\n}\n\nexports.register = register;\n/**\n * Create TypeScript compiler instance.\n */\n\nfunction create(rawOptions = {}) {\n  var _a, _b;\n\n  const dir = (_a = rawOptions.dir) !== null && _a !== void 0 ? _a : exports.DEFAULTS.dir;\n  const compilerName = (_b = rawOptions.compiler) !== null && _b !== void 0 ? _b : exports.DEFAULTS.compiler;\n  const cwd = dir ? path_1.resolve(dir) : process.cwd();\n  /**\n   * Load the typescript compiler. It is required to load the tsconfig but might\n   * be changed by the tsconfig, so we sometimes have to do this twice.\n   */\n\n  function loadCompiler(name) {\n    const compiler = require.resolve(name || 'typescript', {\n      paths: [cwd, __dirname]\n    });\n\n    const ts = require(compiler);\n\n    return {\n      compiler,\n      ts\n    };\n  } // Compute minimum options to read the config file.\n\n\n  let {\n    compiler,\n    ts\n  } = loadCompiler(compilerName); // Read config file and merge new options between env and CLI options.\n\n  const {\n    config,\n    options: tsconfigOptions\n  } = readConfig(cwd, ts, rawOptions);\n  const options = assign({}, exports.DEFAULTS, tsconfigOptions || {}, rawOptions); // If `compiler` option changed based on tsconfig, re-load the compiler.\n\n  if (options.compiler !== compilerName) {\n    ({\n      compiler,\n      ts\n    } = loadCompiler(options.compiler));\n  }\n\n  const readFile = options.readFile || ts.sys.readFile;\n  const fileExists = options.fileExists || ts.sys.fileExists;\n  const transpileOnly = options.transpileOnly === true || options.typeCheck === false;\n  const transformers = options.transformers || undefined;\n  const ignoreDiagnostics = [6059, 18002, 18003, ...(options.ignoreDiagnostics || [])].map(Number);\n  const configDiagnosticList = filterDiagnostics(config.errors, ignoreDiagnostics);\n  const outputCache = new Map();\n  const isScoped = options.scope ? relname => relname.charAt(0) !== '.' : () => true;\n  const shouldIgnore = createIgnore(options.skipIgnore ? [] : (options.ignore || ['(?:^|/)node_modules/']).map(str => new RegExp(str)));\n  const diagnosticHost = {\n    getNewLine: () => ts.sys.newLine,\n    getCurrentDirectory: () => cwd,\n    getCanonicalFileName: ts.sys.useCaseSensitiveFileNames ? x => x : x => x.toLowerCase()\n  }; // Install source map support and read from memory cache.\n\n  sourceMapSupport.install({\n    environment: 'node',\n\n    retrieveFile(path) {\n      var _a;\n\n      return ((_a = outputCache.get(normalizeSlashes(path))) === null || _a === void 0 ? void 0 : _a.content) || '';\n    }\n\n  });\n  const formatDiagnostics = process.stdout.isTTY || options.pretty ? ts.formatDiagnosticsWithColorAndContext || ts.formatDiagnostics : ts.formatDiagnostics;\n\n  function createTSError(diagnostics) {\n    const diagnosticText = formatDiagnostics(diagnostics, diagnosticHost);\n    const diagnosticCodes = diagnostics.map(x => x.code);\n    return new TSError(diagnosticText, diagnosticCodes);\n  }\n\n  function reportTSError(configDiagnosticList) {\n    const error = createTSError(configDiagnosticList);\n\n    if (options.logError) {\n      // Print error in red color and continue execution.\n      console.error('\\x1b[31m%s\\x1b[0m', error);\n    } else {\n      // Throw error and exit the script.\n      throw error;\n    }\n  } // Render the configuration errors.\n\n\n  if (configDiagnosticList.length) reportTSError(configDiagnosticList);\n  /**\n   * Get the extension for a transpiled file.\n   */\n\n  const getExtension = config.options.jsx === ts.JsxEmit.Preserve ? path => /\\.[tj]sx$/.test(path) ? '.jsx' : '.js' : _ => '.js';\n  /**\n   * Create the basic required function using transpile mode.\n   */\n\n  let getOutput;\n  let getTypeInfo;\n\n  const getOutputTranspileOnly = (code, fileName, overrideCompilerOptions) => {\n    const result = ts.transpileModule(code, {\n      fileName,\n      compilerOptions: overrideCompilerOptions ? Object.assign(Object.assign({}, config.options), overrideCompilerOptions) : config.options,\n      reportDiagnostics: true\n    });\n    const diagnosticList = filterDiagnostics(result.diagnostics || [], ignoreDiagnostics);\n    if (diagnosticList.length) reportTSError(diagnosticList);\n    return [result.outputText, result.sourceMapText];\n  }; // Use full language services when the fast option is disabled.\n\n\n  if (!transpileOnly) {\n    const fileContents = new Map();\n    const rootFileNames = config.fileNames.slice();\n    const cachedReadFile = cachedLookup(debugFn('readFile', readFile)); // Use language services by default (TODO: invert next major version).\n\n    if (!options.compilerHost) {\n      let projectVersion = 1;\n      const fileVersions = new Map(rootFileNames.map(fileName => [fileName, 0]));\n\n      const getCustomTransformers = () => {\n        if (typeof transformers === 'function') {\n          const program = service.getProgram();\n          return program ? transformers(program) : undefined;\n        }\n\n        return transformers;\n      }; // Create the compiler host for type checking.\n\n\n      const serviceHost = {\n        getProjectVersion: () => String(projectVersion),\n        getScriptFileNames: () => Array.from(fileVersions.keys()),\n        getScriptVersion: fileName => {\n          const version = fileVersions.get(fileName);\n          return version ? version.toString() : '';\n        },\n\n        getScriptSnapshot(fileName) {\n          let contents = fileContents.get(fileName); // Read contents into TypeScript memory cache.\n\n          if (contents === undefined) {\n            contents = cachedReadFile(fileName);\n            if (contents === undefined) return;\n            fileVersions.set(fileName, 1);\n            fileContents.set(fileName, contents);\n          }\n\n          return ts.ScriptSnapshot.fromString(contents);\n        },\n\n        readFile: cachedReadFile,\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: cachedLookup(debugFn('getDirectories', ts.sys.getDirectories)),\n        fileExists: cachedLookup(debugFn('fileExists', fileExists)),\n        directoryExists: cachedLookup(debugFn('directoryExists', ts.sys.directoryExists)),\n        getNewLine: () => ts.sys.newLine,\n        useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,\n        getCurrentDirectory: () => cwd,\n        getCompilationSettings: () => config.options,\n        getDefaultLibFileName: () => ts.getDefaultLibFilePath(config.options),\n        getCustomTransformers: getCustomTransformers\n      };\n      const registry = ts.createDocumentRegistry(ts.sys.useCaseSensitiveFileNames, cwd);\n      const service = ts.createLanguageService(serviceHost, registry);\n\n      const updateMemoryCache = (contents, fileName) => {\n        // Add to `rootFiles` when discovered for the first time.\n        if (!fileVersions.has(fileName)) {\n          rootFileNames.push(fileName);\n        }\n\n        const previousVersion = fileVersions.get(fileName) || 0;\n        const previousContents = fileContents.get(fileName); // Avoid incrementing cache when nothing has changed.\n\n        if (contents !== previousContents) {\n          fileVersions.set(fileName, previousVersion + 1);\n          fileContents.set(fileName, contents); // Increment project version for every file change.\n\n          projectVersion++;\n        }\n      };\n\n      let previousProgram = undefined;\n\n      getOutput = (code, fileName) => {\n        updateMemoryCache(code, fileName);\n        const programBefore = service.getProgram();\n\n        if (programBefore !== previousProgram) {\n          exports.debug(`compiler rebuilt Program instance when getting output for ${fileName}`);\n        }\n\n        const output = service.getEmitOutput(fileName); // Get the relevant diagnostics - this is 3x faster than `getPreEmitDiagnostics`.\n\n        const diagnostics = service.getSemanticDiagnostics(fileName).concat(service.getSyntacticDiagnostics(fileName));\n        const programAfter = service.getProgram();\n        exports.debug('invariant: Is service.getProject() identical before and after getting emit output and diagnostics? (should always be true) ', programBefore === programAfter);\n        previousProgram = programAfter;\n        const diagnosticList = filterDiagnostics(diagnostics, ignoreDiagnostics);\n        if (diagnosticList.length) reportTSError(diagnosticList);\n\n        if (output.emitSkipped) {\n          throw new TypeError(`${path_1.relative(cwd, fileName)}: Emit skipped`);\n        } // Throw an error when requiring `.d.ts` files.\n\n\n        if (output.outputFiles.length === 0) {\n          throw new TypeError(`Unable to require file: ${path_1.relative(cwd, fileName)}\\n` + 'This is usually the result of a faulty configuration or import. ' + 'Make sure there is a `.js`, `.json` or other executable extension with ' + 'loader attached before `ts-node` available.');\n        }\n\n        return [output.outputFiles[1].text, output.outputFiles[0].text];\n      };\n\n      getTypeInfo = (code, fileName, position) => {\n        updateMemoryCache(code, fileName);\n        const info = service.getQuickInfoAtPosition(fileName, position);\n        const name = ts.displayPartsToString(info ? info.displayParts : []);\n        const comment = ts.displayPartsToString(info ? info.documentation : []);\n        return {\n          name,\n          comment\n        };\n      };\n    } else {\n      const sys = Object.assign(Object.assign(Object.assign({}, ts.sys), diagnosticHost), {\n        readFile: fileName => {\n          const cacheContents = fileContents.get(fileName);\n          if (cacheContents !== undefined) return cacheContents;\n          return cachedReadFile(fileName);\n        },\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: cachedLookup(debugFn('getDirectories', ts.sys.getDirectories)),\n        fileExists: cachedLookup(debugFn('fileExists', fileExists)),\n        directoryExists: cachedLookup(debugFn('directoryExists', ts.sys.directoryExists)),\n        resolvePath: cachedLookup(debugFn('resolvePath', ts.sys.resolvePath)),\n        realpath: ts.sys.realpath ? cachedLookup(debugFn('realpath', ts.sys.realpath)) : undefined\n      });\n      const host = ts.createIncrementalCompilerHost ? ts.createIncrementalCompilerHost(config.options, sys) : Object.assign(Object.assign({}, sys), {\n        getSourceFile: (fileName, languageVersion) => {\n          const contents = sys.readFile(fileName);\n          if (contents === undefined) return;\n          return ts.createSourceFile(fileName, contents, languageVersion);\n        },\n        getDefaultLibLocation: () => normalizeSlashes(path_1.dirname(compiler)),\n        getDefaultLibFileName: () => normalizeSlashes(path_1.join(path_1.dirname(compiler), ts.getDefaultLibFileName(config.options))),\n        useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames\n      }); // Fallback for older TypeScript releases without incremental API.\n\n      let builderProgram = ts.createIncrementalProgram ? ts.createIncrementalProgram({\n        rootNames: rootFileNames.slice(),\n        options: config.options,\n        host: host,\n        configFileParsingDiagnostics: config.errors,\n        projectReferences: config.projectReferences\n      }) : ts.createEmitAndSemanticDiagnosticsBuilderProgram(rootFileNames.slice(), config.options, host, undefined, config.errors, config.projectReferences); // Read and cache custom transformers.\n\n      const customTransformers = typeof transformers === 'function' ? transformers(builderProgram.getProgram()) : transformers; // Set the file contents into cache manually.\n\n      const updateMemoryCache = (contents, fileName) => {\n        const sourceFile = builderProgram.getSourceFile(fileName);\n        fileContents.set(fileName, contents); // Add to `rootFiles` when discovered by compiler for the first time.\n\n        if (sourceFile === undefined) {\n          rootFileNames.push(fileName);\n        } // Update program when file changes.\n\n\n        if (sourceFile === undefined || sourceFile.text !== contents) {\n          builderProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram(rootFileNames.slice(), config.options, host, builderProgram, config.errors, config.projectReferences);\n        }\n      };\n\n      getOutput = (code, fileName) => {\n        const output = ['', ''];\n        updateMemoryCache(code, fileName);\n        const sourceFile = builderProgram.getSourceFile(fileName);\n        if (!sourceFile) throw new TypeError(`Unable to read file: ${fileName}`);\n        const program = builderProgram.getProgram();\n        const diagnostics = ts.getPreEmitDiagnostics(program, sourceFile);\n        const diagnosticList = filterDiagnostics(diagnostics, ignoreDiagnostics);\n        if (diagnosticList.length) reportTSError(diagnosticList);\n        const result = builderProgram.emit(sourceFile, (path, file, writeByteOrderMark) => {\n          if (path.endsWith('.map')) {\n            output[1] = file;\n          } else {\n            output[0] = file;\n          }\n\n          if (options.emit) sys.writeFile(path, file, writeByteOrderMark);\n        }, undefined, undefined, customTransformers);\n\n        if (result.emitSkipped) {\n          throw new TypeError(`${path_1.relative(cwd, fileName)}: Emit skipped`);\n        } // Throw an error when requiring files that cannot be compiled.\n\n\n        if (output[0] === '') {\n          if (program.isSourceFileFromExternalLibrary(sourceFile)) {\n            throw new TypeError(`Unable to compile file from external library: ${path_1.relative(cwd, fileName)}`);\n          }\n\n          throw new TypeError(`Unable to require file: ${path_1.relative(cwd, fileName)}\\n` + 'This is usually the result of a faulty configuration or import. ' + 'Make sure there is a `.js`, `.json` or other executable extension with ' + 'loader attached before `ts-node` available.');\n        }\n\n        return output;\n      };\n\n      getTypeInfo = (code, fileName, position) => {\n        updateMemoryCache(code, fileName);\n        const sourceFile = builderProgram.getSourceFile(fileName);\n        if (!sourceFile) throw new TypeError(`Unable to read file: ${fileName}`);\n        const node = getTokenAtPosition(ts, sourceFile, position);\n        const checker = builderProgram.getProgram().getTypeChecker();\n        const symbol = checker.getSymbolAtLocation(node);\n        if (!symbol) return {\n          name: '',\n          comment: ''\n        };\n        const type = checker.getTypeOfSymbolAtLocation(symbol, node);\n        const signatures = [...type.getConstructSignatures(), ...type.getCallSignatures()];\n        return {\n          name: signatures.length ? signatures.map(x => checker.signatureToString(x)).join('\\n') : checker.typeToString(type),\n          comment: ts.displayPartsToString(symbol ? symbol.getDocumentationComment(checker) : [])\n        };\n      }; // Write `.tsbuildinfo` when `--build` is enabled.\n\n\n      if (options.emit && config.options.incremental) {\n        process.on('exit', () => {\n          // Emits `.tsbuildinfo` to filesystem.\n          builderProgram.getProgram().emitBuildInfo();\n        });\n      }\n    }\n  } else {\n    if (typeof transformers === 'function') {\n      throw new TypeError('Transformers function is unavailable in \"--transpile-only\"');\n    }\n\n    getOutput = getOutputTranspileOnly;\n\n    getTypeInfo = () => {\n      throw new TypeError('Type information is unavailable in \"--transpile-only\"');\n    };\n  }\n\n  const cannotCompileViaBothCodepathsErrorMessage = 'Cannot compile the same file via both `require()` and ESM hooks codepaths. ' + 'This breaks source-map-support, which cannot tell the difference between the two sourcemaps. ' + 'To avoid this problem, load each .ts file as only ESM or only CommonJS.'; // Create a simple TypeScript compiler proxy.\n\n  function compile(code, fileName, lineOffset = 0) {\n    const normalizedFileName = normalizeSlashes(fileName);\n    const [value, sourceMap] = getOutput(code, normalizedFileName);\n    const output = updateOutput(value, normalizedFileName, sourceMap, getExtension);\n    outputCache.set(normalizedFileName, {\n      content: output\n    });\n    return output;\n  }\n\n  let active = true;\n\n  const enabled = enabled => enabled === undefined ? active : active = !!enabled;\n\n  const ignored = fileName => {\n    if (!active) return true;\n    const relname = path_1.relative(cwd, fileName);\n\n    if (!config.options.allowJs) {\n      const ext = path_1.extname(fileName);\n      if (ext === '.js' || ext === '.jsx') return true;\n    }\n\n    return !isScoped(relname) || shouldIgnore(relname);\n  };\n\n  return {\n    ts,\n    config,\n    compile,\n    getTypeInfo,\n    ignored,\n    enabled,\n    options\n  };\n}\n\nexports.create = create;\n/**\n * Check if the filename should be ignored.\n */\n\nfunction createIgnore(ignore) {\n  return relname => {\n    const path = normalizeSlashes(relname);\n    return ignore.some(x => x.test(path));\n  };\n}\n/**\n * \"Refreshes\" an extension on `require.extensions`.\n *\n * @param {string} ext\n */\n\n\nfunction reorderRequireExtension(ext) {\n  const old = require.extensions[ext]; // tslint:disable-line\n\n  delete require.extensions[ext]; // tslint:disable-line\n\n  require.extensions[ext] = old; // tslint:disable-line\n}\n/**\n * Register the extensions to support when importing files.\n */\n\n\nfunction registerExtensions(preferTsExts, extensions, register, originalJsHandler) {\n  // Register new extensions.\n  for (const ext of extensions) {\n    registerExtension(ext, register, originalJsHandler);\n  }\n\n  if (preferTsExts) {\n    // tslint:disable-next-line\n    const preferredExtensions = new Set([...extensions, ...Object.keys(require.extensions)]);\n\n    for (const ext of preferredExtensions) reorderRequireExtension(ext);\n  }\n}\n/**\n * Register the extension for node.\n */\n\n\nfunction registerExtension(ext, register, originalHandler) {\n  const old = require.extensions[ext] || originalHandler; // tslint:disable-line\n\n  require.extensions[ext] = function (m, filename) {\n    if (register.ignored(filename)) return old(m, filename);\n    const _compile = m._compile;\n\n    m._compile = function (code, fileName) {\n      exports.debug('module._compile', fileName);\n      return _compile.call(this, register.compile(code, fileName), fileName);\n    };\n\n    return old(m, filename);\n  };\n}\n/**\n * Do post-processing on config options to support `ts-node`.\n */\n\n\nfunction fixConfig(ts, config) {\n  // Delete options that *should not* be passed through.\n  delete config.options.out;\n  delete config.options.outFile;\n  delete config.options.composite;\n  delete config.options.declarationDir;\n  delete config.options.declarationMap;\n  delete config.options.emitDeclarationOnly; // Target ES5 output by default (instead of ES3).\n\n  if (config.options.target === undefined) {\n    config.options.target = ts.ScriptTarget.ES5;\n  } // Target CommonJS modules by default (instead of magically switching to ES6 when the target is ES6).\n\n\n  if (config.options.module === undefined) {\n    config.options.module = ts.ModuleKind.CommonJS;\n  }\n\n  return config;\n}\n/**\n * Load TypeScript configuration. Returns the parsed TypeScript config and\n * any `ts-node` options specified in the config file.\n */\n\n\nfunction readConfig(cwd, ts, rawOptions) {\n  var _a, _b;\n\n  let config = {\n    compilerOptions: {}\n  };\n  let basePath = cwd;\n  let configFileName = undefined;\n  const {\n    fileExists = ts.sys.fileExists,\n    readFile = ts.sys.readFile,\n    skipProject = exports.DEFAULTS.skipProject,\n    project = exports.DEFAULTS.project\n  } = rawOptions; // Read project configuration when available.\n\n  if (!skipProject) {\n    configFileName = project ? path_1.resolve(cwd, project) : ts.findConfigFile(cwd, fileExists);\n\n    if (configFileName) {\n      const result = ts.readConfigFile(configFileName, readFile); // Return diagnostics.\n\n      if (result.error) {\n        return {\n          config: {\n            errors: [result.error],\n            fileNames: [],\n            options: {}\n          },\n          options: {}\n        };\n      }\n\n      config = result.config;\n      basePath = path_1.dirname(configFileName);\n    }\n  } // Fix ts-node options that come from tsconfig.json\n\n\n  const tsconfigOptions = Object.assign({}, config['ts-node']); // Remove resolution of \"files\".\n\n  const files = (_b = (_a = rawOptions.files) !== null && _a !== void 0 ? _a : tsconfigOptions.files) !== null && _b !== void 0 ? _b : exports.DEFAULTS.files;\n\n  if (!files) {\n    config.files = [];\n    config.include = [];\n  } // Override default configuration options `ts-node` requires.\n\n\n  config.compilerOptions = Object.assign({}, config.compilerOptions, exports.DEFAULTS.compilerOptions, tsconfigOptions.compilerOptions, rawOptions.compilerOptions, TS_NODE_COMPILER_OPTIONS);\n  const fixedConfig = fixConfig(ts, ts.parseJsonConfigFileContent(config, {\n    fileExists,\n    readFile,\n    readDirectory: ts.sys.readDirectory,\n    useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames\n  }, basePath, undefined, configFileName));\n  return {\n    config: fixedConfig,\n    options: tsconfigOptions\n  };\n}\n/**\n * Update the output remapping the source map.\n */\n\n\nfunction updateOutput(outputText, fileName, sourceMap, getExtension) {\n  const base64Map = Buffer.from(updateSourceMap(sourceMap, fileName), 'utf8').toString('base64');\n  const sourceMapContent = `data:application/json;charset=utf-8;base64,${base64Map}`;\n  const sourceMapLength = `${path_1.basename(fileName)}.map`.length + (getExtension(fileName).length - path_1.extname(fileName).length);\n  return outputText.slice(0, -sourceMapLength) + sourceMapContent;\n}\n/**\n * Update the source map contents for improved output.\n */\n\n\nfunction updateSourceMap(sourceMapText, fileName) {\n  const sourceMap = JSON.parse(sourceMapText);\n  sourceMap.file = fileName;\n  sourceMap.sources = [fileName];\n  delete sourceMap.sourceRoot;\n  return JSON.stringify(sourceMap);\n}\n/**\n * Filter diagnostics.\n */\n\n\nfunction filterDiagnostics(diagnostics, ignore) {\n  return diagnostics.filter(x => ignore.indexOf(x.code) === -1);\n}\n/**\n * Get token at file position.\n *\n * Reference: https://github.com/microsoft/TypeScript/blob/fcd9334f57d85b73dd66ad2d21c02e84822f4841/src/services/utilities.ts#L705-L731\n */\n\n\nfunction getTokenAtPosition(ts, sourceFile, position) {\n  let current = sourceFile;\n\n  outer: while (true) {\n    for (const child of current.getChildren(sourceFile)) {\n      const start = child.getFullStart();\n      if (start > position) break;\n      const end = child.getEnd();\n\n      if (position <= end) {\n        current = child;\n        continue outer;\n      }\n    }\n\n    return current;\n  }\n}","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { relative, basename, extname, resolve, dirname, join } from 'path'\nimport sourceMapSupport = require('source-map-support')\nimport * as ynModule from 'yn'\nimport { BaseError } from 'make-error'\nimport * as util from 'util'\nimport * as _ts from 'typescript'\n\n/**\n * Registered `ts-node` instance information.\n */\nexport const REGISTER_INSTANCE = Symbol.for('ts-node.register.instance')\n\n/**\n * Expose `REGISTER_INSTANCE` information on node.js `process`.\n */\ndeclare global {\n  namespace NodeJS {\n    interface Process {\n      [REGISTER_INSTANCE]?: Register\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport const INSPECT_CUSTOM = util.inspect.custom || 'inspect'\n\n/**\n * Wrapper around yn module that returns `undefined` instead of `null`.\n * This is implemented by yn v4, but we're staying on v3 to avoid v4's node 10 requirement.\n */\nfunction yn (value: string | undefined) {\n  return ynModule(value) ?? undefined\n}\n\n/**\n * Debugging `ts-node`.\n */\nconst shouldDebug = yn(process.env.TS_NODE_DEBUG)\n/** @internal */\nexport const debug = shouldDebug ?\n  (...args: any) => console.log(`[ts-node ${new Date().toISOString()}]`, ...args)\n  : () => undefined\nconst debugFn = shouldDebug ?\n  <T, U>(key: string, fn: (arg: T) => U) => {\n    let i = 0\n    return (x: T) => {\n      debug(key, x, ++i)\n      return fn(x)\n    }\n  } :\n  <T, U>(_: string, fn: (arg: T) => U) => fn\n\n/**\n * Common TypeScript interfaces between versions.\n */\nexport interface TSCommon {\n  version: typeof _ts.version\n  sys: typeof _ts.sys\n  ScriptSnapshot: typeof _ts.ScriptSnapshot\n  displayPartsToString: typeof _ts.displayPartsToString\n  createLanguageService: typeof _ts.createLanguageService\n  getDefaultLibFilePath: typeof _ts.getDefaultLibFilePath\n  getPreEmitDiagnostics: typeof _ts.getPreEmitDiagnostics\n  flattenDiagnosticMessageText: typeof _ts.flattenDiagnosticMessageText\n  transpileModule: typeof _ts.transpileModule\n  ModuleKind: typeof _ts.ModuleKind\n  ScriptTarget: typeof _ts.ScriptTarget\n  findConfigFile: typeof _ts.findConfigFile\n  readConfigFile: typeof _ts.readConfigFile\n  parseJsonConfigFileContent: typeof _ts.parseJsonConfigFileContent\n  formatDiagnostics: typeof _ts.formatDiagnostics\n  formatDiagnosticsWithColorAndContext: typeof _ts.formatDiagnosticsWithColorAndContext\n}\n\n/**\n * Export the current version.\n */\nexport const VERSION = require('../package.json').version\n\n/**\n * Options for creating a new TypeScript compiler instance.\n */\nexport interface CreateOptions {\n  /**\n   * Specify working directory for config resolution.\n   *\n   * @default process.cwd()\n   */\n  dir?: string\n  /**\n   * Emit output files into `.ts-node` directory.\n   *\n   * @default false\n   */\n  emit?: boolean\n  /**\n   * Scope compiler to files within `cwd`.\n   *\n   * @default false\n   */\n  scope?: boolean\n  /**\n   * Use pretty diagnostic formatter.\n   *\n   * @default false\n   */\n  pretty?: boolean\n  /**\n   * Use TypeScript's faster `transpileModule`.\n   *\n   * @default false\n   */\n  transpileOnly?: boolean\n  /**\n   * **DEPRECATED** Specify type-check is enabled (e.g. `transpileOnly == false`).\n   *\n   * @default true\n   */\n  typeCheck?: boolean\n  /**\n   * Use TypeScript's compiler host API.\n   *\n   * @default false\n   */\n  compilerHost?: boolean\n  /**\n   * Logs TypeScript errors to stderr instead of throwing exceptions.\n   *\n   * @default false\n   */\n  logError?: boolean\n  /**\n   * Load files from `tsconfig.json` on startup.\n   *\n   * @default false\n   */\n  files?: boolean\n  /**\n   * Specify a custom TypeScript compiler.\n   *\n   * @default \"typescript\"\n   */\n  compiler?: string\n  /**\n   * Override the path patterns to skip compilation.\n   *\n   * @default /node_modules/\n   * @docsDefault \"/node_modules/\"\n   */\n  ignore?: string[]\n  /**\n   * Path to TypeScript JSON project file.\n   */\n  project?: string\n  /**\n   * Skip project config resolution and loading.\n   *\n   * @default false\n   */\n  skipProject?: boolean\n  /**\n   * Skip ignore check.\n   *\n   * @default false\n   */\n  skipIgnore?: boolean\n  /**\n   * JSON object to merge with compiler options.\n   *\n   * @allOf [{\"$ref\": \"https://schemastore.azurewebsites.net/schemas/json/tsconfig.json#definitions/compilerOptionsDefinition/properties/compilerOptions\"}]\n   */\n  compilerOptions?: object\n  /**\n   * Ignore TypeScript warnings by diagnostic code.\n   */\n  ignoreDiagnostics?: Array<number | string>\n  readFile?: (path: string) => string | undefined\n  fileExists?: (path: string) => boolean\n  transformers?: _ts.CustomTransformers | ((p: _ts.Program) => _ts.CustomTransformers)\n}\n\n/**\n * Options for registering a TypeScript compiler instance globally.\n */\nexport interface RegisterOptions extends CreateOptions {\n  /**\n   * Re-order file extensions so that TypeScript imports are preferred.\n   *\n   * @default false\n   */\n  preferTsExts?: boolean\n}\n\n/**\n * Must be an interface to support `typescript-json-schema`.\n */\nexport interface TsConfigOptions extends Omit<RegisterOptions,\n  | 'transformers'\n  | 'readFile'\n  | 'fileExists'\n  | 'skipProject'\n  | 'project'\n  | 'dir'\n  > { }\n\n/**\n * Like `Object.assign`, but ignores `undefined` properties.\n */\nfunction assign<T extends object> (initialValue: T, ...sources: Array<T>): T {\n  for (const source of sources) {\n    for (const key of Object.keys(source)) {\n      const value = (source as any)[key]\n      if (value !== undefined) (initialValue as any)[key] = value\n    }\n  }\n  return initialValue\n}\n\n/**\n * Information retrieved from type info check.\n */\nexport interface TypeInfo {\n  name: string\n  comment: string\n}\n\n/**\n * Default register options, including values specified via environment\n * variables.\n */\nexport const DEFAULTS: RegisterOptions = {\n  dir: process.env.TS_NODE_DIR,\n  emit: yn(process.env.TS_NODE_EMIT),\n  scope: yn(process.env.TS_NODE_SCOPE),\n  files: yn(process.env.TS_NODE_FILES),\n  pretty: yn(process.env.TS_NODE_PRETTY),\n  compiler: process.env.TS_NODE_COMPILER,\n  compilerOptions: parse(process.env.TS_NODE_COMPILER_OPTIONS),\n  ignore: split(process.env.TS_NODE_IGNORE),\n  project: process.env.TS_NODE_PROJECT,\n  skipProject: yn(process.env.TS_NODE_SKIP_PROJECT),\n  skipIgnore: yn(process.env.TS_NODE_SKIP_IGNORE),\n  preferTsExts: yn(process.env.TS_NODE_PREFER_TS_EXTS),\n  ignoreDiagnostics: split(process.env.TS_NODE_IGNORE_DIAGNOSTICS),\n  transpileOnly: yn(process.env.TS_NODE_TRANSPILE_ONLY),\n  typeCheck: yn(process.env.TS_NODE_TYPE_CHECK),\n  compilerHost: yn(process.env.TS_NODE_COMPILER_HOST),\n  logError: yn(process.env.TS_NODE_LOG_ERROR)\n}\n\n/**\n * Default TypeScript compiler options required by `ts-node`.\n */\nconst TS_NODE_COMPILER_OPTIONS = {\n  sourceMap: true,\n  inlineSourceMap: false,\n  inlineSources: true,\n  declaration: false,\n  noEmit: false,\n  outDir: '.ts-node'\n}\n\n/**\n * Split a string array of values.\n */\nexport function split (value: string | undefined) {\n  return typeof value === 'string' ? value.split(/ *, */g) : undefined\n}\n\n/**\n * Parse a string as JSON.\n */\nexport function parse (value: string | undefined): object | undefined {\n  return typeof value === 'string' ? JSON.parse(value) : undefined\n}\n\n/**\n * Replace backslashes with forward slashes.\n */\nexport function normalizeSlashes (value: string): string {\n  return value.replace(/\\\\/g, '/')\n}\n\n/**\n * TypeScript diagnostics error.\n */\nexport class TSError extends BaseError {\n  name = 'TSError'\n\n  constructor (public diagnosticText: string, public diagnosticCodes: number[]) {\n    super(`тип Unable to compile TypeScript:\\n${diagnosticText}`)\n  }\n\n  /**\n   * @internal\n   */\n  [INSPECT_CUSTOM] () {\n    return this.diagnosticText\n  }\n}\n\n/**\n * Return type for registering `ts-node`.\n */\nexport interface Register {\n  ts: TSCommon\n  config: _ts.ParsedCommandLine\n  options: RegisterOptions\n  enabled (enabled?: boolean): boolean\n  ignored (fileName: string): boolean\n  compile (code: string, fileName: string, lineOffset?: number): string\n  getTypeInfo (code: string, fileName: string, position: number): TypeInfo\n}\n\n/**\n * Cached fs operation wrapper.\n */\nfunction cachedLookup<T> (fn: (arg: string) => T): (arg: string) => T {\n  const cache = new Map<string, T>()\n\n  return (arg: string): T => {\n    if (!cache.has(arg)) {\n      cache.set(arg, fn(arg))\n    }\n\n    return cache.get(arg)!\n  }\n}\n\n/** @internal */\nexport function getExtensions (config: _ts.ParsedCommandLine) {\n  const tsExtensions = ['.ts']\n  const jsExtensions = []\n\n  // Enable additional extensions when JSX or `allowJs` is enabled.\n  if (config.options.jsx) tsExtensions.push('.tsx')\n  if (config.options.allowJs) jsExtensions.push('.js')\n  if (config.options.jsx && config.options.allowJs) jsExtensions.push('.jsx')\n  return { tsExtensions, jsExtensions }\n}\n\n/**\n * Register TypeScript compiler instance onto node.js\n */\nexport function register (opts: RegisterOptions = {}): Register {\n  const originalJsHandler = require.extensions['.js'] // tslint:disable-line\n  const service = create(opts)\n  const { tsExtensions, jsExtensions } = getExtensions(service.config)\n  const extensions = [...tsExtensions, ...jsExtensions]\n\n  // Expose registered instance globally.\n  process[REGISTER_INSTANCE] = service\n\n  // Register the extensions.\n  registerExtensions(service.options.preferTsExts, extensions, service, originalJsHandler)\n\n  return service\n}\n\n/**\n * Create TypeScript compiler instance.\n */\nexport function create (rawOptions: CreateOptions = {}): Register {\n  const dir = rawOptions.dir ?? DEFAULTS.dir\n  const compilerName = rawOptions.compiler ?? DEFAULTS.compiler\n  const cwd = dir ? resolve(dir) : process.cwd()\n\n  /**\n   * Load the typescript compiler. It is required to load the tsconfig but might\n   * be changed by the tsconfig, so we sometimes have to do this twice.\n   */\n  function loadCompiler (name: string | undefined) {\n    const compiler = require.resolve(name || 'typescript', { paths: [cwd, __dirname] })\n    const ts: typeof _ts = require(compiler)\n    return { compiler, ts }\n  }\n\n  // Compute minimum options to read the config file.\n  let { compiler, ts } = loadCompiler(compilerName)\n\n  // Read config file and merge new options between env and CLI options.\n  const { config, options: tsconfigOptions } = readConfig(cwd, ts, rawOptions)\n  const options = assign<CreateOptions>({}, DEFAULTS, tsconfigOptions || {}, rawOptions)\n\n  // If `compiler` option changed based on tsconfig, re-load the compiler.\n  if (options.compiler !== compilerName) {\n    ({ compiler, ts } = loadCompiler(options.compiler))\n  }\n\n  const readFile = options.readFile || ts.sys.readFile\n  const fileExists = options.fileExists || ts.sys.fileExists\n  const transpileOnly = options.transpileOnly === true || options.typeCheck === false\n  const transformers = options.transformers || undefined\n  const ignoreDiagnostics = [\n    6059, // \"'rootDir' is expected to contain all source files.\"\n    18002, // \"The 'files' list in config file is empty.\"\n    18003, // \"No inputs were found in config file.\"\n    ...(options.ignoreDiagnostics || [])\n  ].map(Number)\n\n  const configDiagnosticList = filterDiagnostics(config.errors, ignoreDiagnostics)\n  const outputCache = new Map<string, {\n    content: string\n  }>()\n\n  const isScoped = options.scope ? (relname: string) => relname.charAt(0) !== '.' : () => true\n  const shouldIgnore = createIgnore(options.skipIgnore ? [] : (\n    options.ignore || ['(?:^|/)node_modules/']\n  ).map(str => new RegExp(str)))\n\n  const diagnosticHost: _ts.FormatDiagnosticsHost = {\n    getNewLine: () => ts.sys.newLine,\n    getCurrentDirectory: () => cwd,\n    getCanonicalFileName: ts.sys.useCaseSensitiveFileNames ? x => x : x => x.toLowerCase()\n  }\n\n  // Install source map support and read from memory cache.\n  sourceMapSupport.install({\n    environment: 'node',\n    retrieveFile (path: string) {\n      return outputCache.get(normalizeSlashes(path))?.content || ''\n    }\n  })\n\n  const formatDiagnostics = process.stdout.isTTY || options.pretty\n    ? (ts.formatDiagnosticsWithColorAndContext || ts.formatDiagnostics)\n    : ts.formatDiagnostics\n\n  function createTSError (diagnostics: ReadonlyArray<_ts.Diagnostic>) {\n    const diagnosticText = formatDiagnostics(diagnostics, diagnosticHost)\n    const diagnosticCodes = diagnostics.map(x => x.code)\n    return new TSError(diagnosticText, diagnosticCodes)\n  }\n\n  function reportTSError (configDiagnosticList: _ts.Diagnostic[]) {\n    const error = createTSError(configDiagnosticList)\n    if (options.logError) {\n      // Print error in red color and continue execution.\n      console.error('\\x1b[31m%s\\x1b[0m', error)\n    } else {\n      // Throw error and exit the script.\n      throw error\n    }\n  }\n\n  // Render the configuration errors.\n  if (configDiagnosticList.length) reportTSError(configDiagnosticList)\n\n  /**\n   * Get the extension for a transpiled file.\n   */\n  const getExtension = config.options.jsx === ts.JsxEmit.Preserve ?\n    ((path: string) => /\\.[tj]sx$/.test(path) ? '.jsx' : '.js') :\n    ((_: string) => '.js')\n\n  /**\n   * Create the basic required function using transpile mode.\n   */\n  let getOutput: (code: string, fileName: string) => SourceOutput\n  let getTypeInfo: (_code: string, _fileName: string, _position: number) => TypeInfo\n\n  const getOutputTranspileOnly = (code: string, fileName: string, overrideCompilerOptions?: Partial<_ts.CompilerOptions>): SourceOutput => {\n    const result = ts.transpileModule(code, {\n      fileName,\n      compilerOptions: overrideCompilerOptions ? { ...config.options, ...overrideCompilerOptions } : config.options,\n      reportDiagnostics: true\n    })\n\n    const diagnosticList = filterDiagnostics(result.diagnostics || [], ignoreDiagnostics)\n    if (diagnosticList.length) reportTSError(diagnosticList)\n\n    return [result.outputText, result.sourceMapText as string]\n  }\n\n  // Use full language services when the fast option is disabled.\n  if (!transpileOnly) {\n    const fileContents = new Map<string, string>()\n    const rootFileNames = config.fileNames.slice()\n    const cachedReadFile = cachedLookup(debugFn('readFile', readFile))\n\n    // Use language services by default (TODO: invert next major version).\n    if (!options.compilerHost) {\n      let projectVersion = 1\n      const fileVersions = new Map(rootFileNames.map(fileName => [fileName, 0]))\n\n      const getCustomTransformers = () => {\n        if (typeof transformers === 'function') {\n          const program = service.getProgram()\n          return program ? transformers(program) : undefined\n        }\n\n        return transformers\n      }\n\n      // Create the compiler host for type checking.\n      const serviceHost: _ts.LanguageServiceHost = {\n        getProjectVersion: () => String(projectVersion),\n        getScriptFileNames: () => Array.from(fileVersions.keys()),\n        getScriptVersion: (fileName: string) => {\n          const version = fileVersions.get(fileName)\n          return version ? version.toString() : ''\n        },\n        getScriptSnapshot (fileName: string) {\n          let contents = fileContents.get(fileName)\n\n          // Read contents into TypeScript memory cache.\n          if (contents === undefined) {\n            contents = cachedReadFile(fileName)\n            if (contents === undefined) return\n\n            fileVersions.set(fileName, 1)\n            fileContents.set(fileName, contents)\n          }\n\n          return ts.ScriptSnapshot.fromString(contents)\n        },\n        readFile: cachedReadFile,\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: cachedLookup(debugFn('getDirectories', ts.sys.getDirectories)),\n        fileExists: cachedLookup(debugFn('fileExists', fileExists)),\n        directoryExists: cachedLookup(debugFn('directoryExists', ts.sys.directoryExists)),\n        getNewLine: () => ts.sys.newLine,\n        useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,\n        getCurrentDirectory: () => cwd,\n        getCompilationSettings: () => config.options,\n        getDefaultLibFileName: () => ts.getDefaultLibFilePath(config.options),\n        getCustomTransformers: getCustomTransformers\n      }\n\n      const registry = ts.createDocumentRegistry(ts.sys.useCaseSensitiveFileNames, cwd)\n      const service = ts.createLanguageService(serviceHost, registry)\n\n      const updateMemoryCache = (contents: string, fileName: string) => {\n        // Add to `rootFiles` when discovered for the first time.\n        if (!fileVersions.has(fileName)) {\n          rootFileNames.push(fileName)\n        }\n\n        const previousVersion = fileVersions.get(fileName) || 0\n        const previousContents = fileContents.get(fileName)\n        // Avoid incrementing cache when nothing has changed.\n        if (contents !== previousContents) {\n          fileVersions.set(fileName, previousVersion + 1)\n          fileContents.set(fileName, contents)\n          // Increment project version for every file change.\n          projectVersion++\n        }\n      }\n\n      let previousProgram: _ts.Program | undefined = undefined\n\n      getOutput = (code: string, fileName: string) => {\n        updateMemoryCache(code, fileName)\n\n        const programBefore = service.getProgram()\n        if (programBefore !== previousProgram) {\n          debug(`compiler rebuilt Program instance when getting output for ${fileName}`)\n        }\n\n        const output = service.getEmitOutput(fileName)\n\n        // Get the relevant diagnostics - this is 3x faster than `getPreEmitDiagnostics`.\n        const diagnostics = service.getSemanticDiagnostics(fileName)\n          .concat(service.getSyntacticDiagnostics(fileName))\n\n        const programAfter = service.getProgram()\n\n        debug(\n          'invariant: Is service.getProject() identical before and after getting emit output and diagnostics? (should always be true) ',\n          programBefore === programAfter\n        )\n\n        previousProgram = programAfter\n\n        const diagnosticList = filterDiagnostics(diagnostics, ignoreDiagnostics)\n        if (diagnosticList.length) reportTSError(diagnosticList)\n\n        if (output.emitSkipped) {\n          throw new TypeError(`${relative(cwd, fileName)}: Emit skipped`)\n        }\n\n        // Throw an error when requiring `.d.ts` files.\n        if (output.outputFiles.length === 0) {\n          throw new TypeError(\n            `Unable to require file: ${relative(cwd, fileName)}\\n` +\n            'This is usually the result of a faulty configuration or import. ' +\n            'Make sure there is a `.js`, `.json` or other executable extension with ' +\n            'loader attached before `ts-node` available.'\n          )\n        }\n\n        return [output.outputFiles[1].text, output.outputFiles[0].text]\n      }\n\n      getTypeInfo = (code: string, fileName: string, position: number) => {\n        updateMemoryCache(code, fileName)\n\n        const info = service.getQuickInfoAtPosition(fileName, position)\n        const name = ts.displayPartsToString(info ? info.displayParts : [])\n        const comment = ts.displayPartsToString(info ? info.documentation : [])\n\n        return { name, comment }\n      }\n    } else {\n      const sys = {\n        ...ts.sys,\n        ...diagnosticHost,\n        readFile: (fileName: string) => {\n          const cacheContents = fileContents.get(fileName)\n          if (cacheContents !== undefined) return cacheContents\n          return cachedReadFile(fileName)\n        },\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: cachedLookup(debugFn('getDirectories', ts.sys.getDirectories)),\n        fileExists: cachedLookup(debugFn('fileExists', fileExists)),\n        directoryExists: cachedLookup(debugFn('directoryExists', ts.sys.directoryExists)),\n        resolvePath: cachedLookup(debugFn('resolvePath', ts.sys.resolvePath)),\n        realpath: ts.sys.realpath ? cachedLookup(debugFn('realpath', ts.sys.realpath)) : undefined\n      }\n\n      const host: _ts.CompilerHost = ts.createIncrementalCompilerHost\n        ? ts.createIncrementalCompilerHost(config.options, sys)\n        : {\n          ...sys,\n          getSourceFile: (fileName, languageVersion) => {\n            const contents = sys.readFile(fileName)\n            if (contents === undefined) return\n            return ts.createSourceFile(fileName, contents, languageVersion)\n          },\n          getDefaultLibLocation: () => normalizeSlashes(dirname(compiler)),\n          getDefaultLibFileName: () => normalizeSlashes(join(dirname(compiler), ts.getDefaultLibFileName(config.options))),\n          useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames\n        }\n\n      // Fallback for older TypeScript releases without incremental API.\n      let builderProgram = ts.createIncrementalProgram\n        ? ts.createIncrementalProgram({\n          rootNames: rootFileNames.slice(),\n          options: config.options,\n          host: host,\n          configFileParsingDiagnostics: config.errors,\n          projectReferences: config.projectReferences\n        })\n        : ts.createEmitAndSemanticDiagnosticsBuilderProgram(\n          rootFileNames.slice(),\n          config.options,\n          host,\n          undefined,\n          config.errors,\n          config.projectReferences\n        )\n\n      // Read and cache custom transformers.\n      const customTransformers = typeof transformers === 'function'\n        ? transformers(builderProgram.getProgram())\n        : transformers\n\n      // Set the file contents into cache manually.\n      const updateMemoryCache = (contents: string, fileName: string) => {\n        const sourceFile = builderProgram.getSourceFile(fileName)\n\n        fileContents.set(fileName, contents)\n\n        // Add to `rootFiles` when discovered by compiler for the first time.\n        if (sourceFile === undefined) {\n          rootFileNames.push(fileName)\n        }\n\n        // Update program when file changes.\n        if (sourceFile === undefined || sourceFile.text !== contents) {\n          builderProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram(\n            rootFileNames.slice(),\n            config.options,\n            host,\n            builderProgram,\n            config.errors,\n            config.projectReferences\n          )\n        }\n      }\n\n      getOutput = (code: string, fileName: string) => {\n        const output: [string, string] = ['', '']\n\n        updateMemoryCache(code, fileName)\n\n        const sourceFile = builderProgram.getSourceFile(fileName)\n        if (!sourceFile) throw new TypeError(`Unable to read file: ${fileName}`)\n\n        const program = builderProgram.getProgram()\n        const diagnostics = ts.getPreEmitDiagnostics(program, sourceFile)\n        const diagnosticList = filterDiagnostics(diagnostics, ignoreDiagnostics)\n        if (diagnosticList.length) reportTSError(diagnosticList)\n\n        const result = builderProgram.emit(sourceFile, (path, file, writeByteOrderMark) => {\n          if (path.endsWith('.map')) {\n            output[1] = file\n          } else {\n            output[0] = file\n          }\n\n          if (options.emit) sys.writeFile(path, file, writeByteOrderMark)\n        }, undefined, undefined, customTransformers)\n\n        if (result.emitSkipped) {\n          throw new TypeError(`${relative(cwd, fileName)}: Emit skipped`)\n        }\n\n        // Throw an error when requiring files that cannot be compiled.\n        if (output[0] === '') {\n          if (program.isSourceFileFromExternalLibrary(sourceFile)) {\n            throw new TypeError(`Unable to compile file from external library: ${relative(cwd, fileName)}`)\n          }\n\n          throw new TypeError(\n            `Unable to require file: ${relative(cwd, fileName)}\\n` +\n            'This is usually the result of a faulty configuration or import. ' +\n            'Make sure there is a `.js`, `.json` or other executable extension with ' +\n            'loader attached before `ts-node` available.'\n          )\n        }\n\n        return output\n      }\n\n      getTypeInfo = (code: string, fileName: string, position: number) => {\n        updateMemoryCache(code, fileName)\n\n        const sourceFile = builderProgram.getSourceFile(fileName)\n        if (!sourceFile) throw new TypeError(`Unable to read file: ${fileName}`)\n\n        const node = getTokenAtPosition(ts, sourceFile, position)\n        const checker = builderProgram.getProgram().getTypeChecker()\n        const symbol = checker.getSymbolAtLocation(node)\n\n        if (!symbol) return { name: '', comment: '' }\n\n        const type = checker.getTypeOfSymbolAtLocation(symbol, node)\n        const signatures = [...type.getConstructSignatures(), ...type.getCallSignatures()]\n\n        return {\n          name: signatures.length ? signatures.map(x => checker.signatureToString(x)).join('\\n') : checker.typeToString(type),\n          comment: ts.displayPartsToString(symbol ? symbol.getDocumentationComment(checker) : [])\n        }\n      }\n\n      // Write `.tsbuildinfo` when `--build` is enabled.\n      if (options.emit && config.options.incremental) {\n        process.on('exit', () => {\n          // Emits `.tsbuildinfo` to filesystem.\n          (builderProgram.getProgram() as any).emitBuildInfo()\n        })\n      }\n    }\n  } else {\n    if (typeof transformers === 'function') {\n      throw new TypeError('Transformers function is unavailable in \"--transpile-only\"')\n    }\n\n    getOutput = getOutputTranspileOnly\n\n    getTypeInfo = () => {\n      throw new TypeError('Type information is unavailable in \"--transpile-only\"')\n    }\n  }\n\n  const cannotCompileViaBothCodepathsErrorMessage = 'Cannot compile the same file via both `require()` and ESM hooks codepaths. ' +\n    'This breaks source-map-support, which cannot tell the difference between the two sourcemaps. ' +\n    'To avoid this problem, load each .ts file as only ESM or only CommonJS.'\n  // Create a simple TypeScript compiler proxy.\n  function compile (code: string, fileName: string, lineOffset = 0) {\n    const normalizedFileName = normalizeSlashes(fileName)\n    const [value, sourceMap] = getOutput(code, normalizedFileName)\n    const output = updateOutput(value, normalizedFileName, sourceMap, getExtension)\n    outputCache.set(normalizedFileName, { content: output })\n    return output\n  }\n\n  let active = true\n  const enabled = (enabled?: boolean) => enabled === undefined ? active : (active = !!enabled)\n  const ignored = (fileName: string) => {\n    if (!active) return true\n    const relname = relative(cwd, fileName)\n    if (!config.options.allowJs) {\n      const ext = extname(fileName)\n      if (ext === '.js' || ext === '.jsx') return true\n    }\n    return !isScoped(relname) || shouldIgnore(relname)\n  }\n\n  return { ts, config, compile, getTypeInfo, ignored, enabled, options }\n}\n\n/**\n * Check if the filename should be ignored.\n */\nfunction createIgnore (ignore: RegExp[]) {\n  return (relname: string) => {\n    const path = normalizeSlashes(relname)\n\n    return ignore.some(x => x.test(path))\n  }\n}\n\n/**\n * \"Refreshes\" an extension on `require.extensions`.\n *\n * @param {string} ext\n */\nfunction reorderRequireExtension (ext: string) {\n  const old = require.extensions[ext] // tslint:disable-line\n  delete require.extensions[ext] // tslint:disable-line\n  require.extensions[ext] = old // tslint:disable-line\n}\n\n/**\n * Register the extensions to support when importing files.\n */\nfunction registerExtensions (\n  preferTsExts: boolean | null | undefined,\n  extensions: string[],\n  register: Register,\n  originalJsHandler: (m: NodeModule, filename: string) => any\n) {\n  // Register new extensions.\n  for (const ext of extensions) {\n    registerExtension(ext, register, originalJsHandler)\n  }\n\n  if (preferTsExts) {\n    // tslint:disable-next-line\n    const preferredExtensions = new Set([...extensions, ...Object.keys(require.extensions)])\n\n    for (const ext of preferredExtensions) reorderRequireExtension(ext)\n  }\n}\n\n/**\n * Register the extension for node.\n */\nfunction registerExtension (\n  ext: string,\n  register: Register,\n  originalHandler: (m: NodeModule, filename: string) => any\n) {\n  const old = require.extensions[ext] || originalHandler // tslint:disable-line\n\n  require.extensions[ext] = function (m: any, filename) { // tslint:disable-line\n    if (register.ignored(filename)) return old(m, filename)\n\n    const _compile = m._compile\n\n    m._compile = function (code: string, fileName: string) {\n      debug('module._compile', fileName)\n\n      return _compile.call(this, register.compile(code, fileName), fileName)\n    }\n\n    return old(m, filename)\n  }\n}\n\n/**\n * Do post-processing on config options to support `ts-node`.\n */\nfunction fixConfig (ts: TSCommon, config: _ts.ParsedCommandLine) {\n  // Delete options that *should not* be passed through.\n  delete config.options.out\n  delete config.options.outFile\n  delete config.options.composite\n  delete config.options.declarationDir\n  delete config.options.declarationMap\n  delete config.options.emitDeclarationOnly\n\n  // Target ES5 output by default (instead of ES3).\n  if (config.options.target === undefined) {\n    config.options.target = ts.ScriptTarget.ES5\n  }\n\n  // Target CommonJS modules by default (instead of magically switching to ES6 when the target is ES6).\n  if (config.options.module === undefined) {\n    config.options.module = ts.ModuleKind.CommonJS\n  }\n\n  return config\n}\n\n/**\n * Load TypeScript configuration. Returns the parsed TypeScript config and\n * any `ts-node` options specified in the config file.\n */\nfunction readConfig (\n  cwd: string,\n  ts: TSCommon,\n  rawOptions: CreateOptions\n): {\n  // Parsed TypeScript configuration.\n  config: _ts.ParsedCommandLine\n  // Options pulled from `tsconfig.json`.\n  options: TsConfigOptions\n} {\n  let config: any = { compilerOptions: {} }\n  let basePath = cwd\n  let configFileName: string | undefined = undefined\n\n  const {\n    fileExists = ts.sys.fileExists,\n    readFile = ts.sys.readFile,\n    skipProject = DEFAULTS.skipProject,\n    project = DEFAULTS.project\n  } = rawOptions\n\n  // Read project configuration when available.\n  if (!skipProject) {\n    configFileName = project\n      ? resolve(cwd, project)\n      : ts.findConfigFile(cwd, fileExists)\n\n    if (configFileName) {\n      const result = ts.readConfigFile(configFileName, readFile)\n\n      // Return diagnostics.\n      if (result.error) {\n        return {\n          config: { errors: [result.error], fileNames: [], options: {} },\n          options: {}\n        }\n      }\n\n      config = result.config\n      basePath = dirname(configFileName)\n    }\n  }\n\n  // Fix ts-node options that come from tsconfig.json\n  const tsconfigOptions: TsConfigOptions = Object.assign({}, config['ts-node'])\n\n  // Remove resolution of \"files\".\n  const files = rawOptions.files ?? tsconfigOptions.files ?? DEFAULTS.files\n  if (!files) {\n    config.files = []\n    config.include = []\n  }\n\n  // Override default configuration options `ts-node` requires.\n  config.compilerOptions = Object.assign(\n    {},\n    config.compilerOptions,\n    DEFAULTS.compilerOptions,\n    tsconfigOptions.compilerOptions,\n    rawOptions.compilerOptions,\n    TS_NODE_COMPILER_OPTIONS\n  )\n\n  const fixedConfig = fixConfig(ts, ts.parseJsonConfigFileContent(config, {\n    fileExists,\n    readFile,\n    readDirectory: ts.sys.readDirectory,\n    useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames\n  }, basePath, undefined, configFileName))\n\n  return { config: fixedConfig, options: tsconfigOptions }\n}\n\n/**\n * Internal source output.\n */\ntype SourceOutput = [string, string]\n\n/**\n * Update the output remapping the source map.\n */\nfunction updateOutput (outputText: string, fileName: string, sourceMap: string, getExtension: (fileName: string) => string) {\n  const base64Map = Buffer.from(updateSourceMap(sourceMap, fileName), 'utf8').toString('base64')\n  const sourceMapContent = `data:application/json;charset=utf-8;base64,${base64Map}`\n  const sourceMapLength = `${basename(fileName)}.map`.length + (getExtension(fileName).length - extname(fileName).length)\n\n  return outputText.slice(0, -sourceMapLength) + sourceMapContent\n}\n\n/**\n * Update the source map contents for improved output.\n */\nfunction updateSourceMap (sourceMapText: string, fileName: string) {\n  const sourceMap = JSON.parse(sourceMapText)\n  sourceMap.file = fileName\n  sourceMap.sources = [fileName]\n  delete sourceMap.sourceRoot\n  return JSON.stringify(sourceMap)\n}\n\n/**\n * Filter diagnostics.\n */\nfunction filterDiagnostics (diagnostics: readonly _ts.Diagnostic[], ignore: number[]) {\n  return diagnostics.filter(x => ignore.indexOf(x.code) === -1)\n}\n\n/**\n * Get token at file position.\n *\n * Reference: https://github.com/microsoft/TypeScript/blob/fcd9334f57d85b73dd66ad2d21c02e84822f4841/src/services/utilities.ts#L705-L731\n */\nfunction getTokenAtPosition (ts: typeof _ts, sourceFile: _ts.SourceFile, position: number): _ts.Node {\n  let current: _ts.Node = sourceFile\n\n  outer: while (true) {\n    for (const child of current.getChildren(sourceFile)) {\n      const start = child.getFullStart()\n      if (start > position) break\n\n      const end = child.getEnd()\n      if (position <= end) {\n        current = child\n        continue outer\n      }\n    }\n\n    return current\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}