{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport objectEntries from '../polyfills/objectEntries';\nimport inspect from '../jsutils/inspect';\nimport keyMap from '../jsutils/keyMap';\nimport mapValue from '../jsutils/mapValue';\nimport toObjMap from '../jsutils/toObjMap';\nimport devAssert from '../jsutils/devAssert';\nimport keyValMap from '../jsutils/keyValMap';\nimport instanceOf from '../jsutils/instanceOf';\nimport isObjectLike from '../jsutils/isObjectLike';\nimport identityFunc from '../jsutils/identityFunc';\nimport defineToJSON from '../jsutils/defineToJSON';\nimport defineToStringTag from '../jsutils/defineToStringTag';\nimport { Kind } from '../language/kinds';\nimport { valueFromASTUntyped } from '../utilities/valueFromASTUntyped';\nexport function isType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);\n}\nexport function assertType(type) {\n  if (!isType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL type.\"));\n  }\n\n  return type;\n}\n/**\n * There are predicates for each kind of GraphQL type.\n */\n// eslint-disable-next-line no-redeclare\n\nexport function isScalarType(type) {\n  return instanceOf(type, GraphQLScalarType);\n}\nexport function assertScalarType(type) {\n  if (!isScalarType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Scalar type.\"));\n  }\n\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isObjectType(type) {\n  return instanceOf(type, GraphQLObjectType);\n}\nexport function assertObjectType(type) {\n  if (!isObjectType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Object type.\"));\n  }\n\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isInterfaceType(type) {\n  return instanceOf(type, GraphQLInterfaceType);\n}\nexport function assertInterfaceType(type) {\n  if (!isInterfaceType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Interface type.\"));\n  }\n\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isUnionType(type) {\n  return instanceOf(type, GraphQLUnionType);\n}\nexport function assertUnionType(type) {\n  if (!isUnionType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Union type.\"));\n  }\n\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isEnumType(type) {\n  return instanceOf(type, GraphQLEnumType);\n}\nexport function assertEnumType(type) {\n  if (!isEnumType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Enum type.\"));\n  }\n\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isInputObjectType(type) {\n  return instanceOf(type, GraphQLInputObjectType);\n}\nexport function assertInputObjectType(type) {\n  if (!isInputObjectType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Input Object type.\"));\n  }\n\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isListType(type) {\n  return instanceOf(type, GraphQLList);\n}\nexport function assertListType(type) {\n  if (!isListType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL List type.\"));\n  }\n\n  return type;\n} // eslint-disable-next-line no-redeclare\n\nexport function isNonNullType(type) {\n  return instanceOf(type, GraphQLNonNull);\n}\nexport function assertNonNullType(type) {\n  if (!isNonNullType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Non-Null type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may be used as input types for arguments and directives.\n */\n\nexport function isInputType(type) {\n  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);\n}\nexport function assertInputType(type) {\n  if (!isInputType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL input type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may be used as output types as the result of fields.\n */\n\nexport function isOutputType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);\n}\nexport function assertOutputType(type) {\n  if (!isOutputType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL output type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may describe types which may be leaf values.\n */\n\nexport function isLeafType(type) {\n  return isScalarType(type) || isEnumType(type);\n}\nexport function assertLeafType(type) {\n  if (!isLeafType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL leaf type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isCompositeType(type) {\n  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);\n}\nexport function assertCompositeType(type) {\n  if (!isCompositeType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL composite type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isAbstractType(type) {\n  return isInterfaceType(type) || isUnionType(type);\n}\nexport function assertAbstractType(type) {\n  if (!isAbstractType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL abstract type.\"));\n  }\n\n  return type;\n}\n/**\n * List Type Wrapper\n *\n * A list is a wrapping type which points to another type.\n * Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         parents: { type: GraphQLList(PersonType) },\n *         children: { type: GraphQLList(PersonType) },\n *       })\n *     })\n *\n */\n// eslint-disable-next-line no-redeclare\n\nexport function GraphQLList(ofType) {\n  if (this instanceof GraphQLList) {\n    this.ofType = assertType(ofType);\n  } else {\n    return new GraphQLList(ofType);\n  }\n} // Need to cast through any to alter the prototype.\n\nGraphQLList.prototype.toString = function toString() {\n  return '[' + String(this.ofType) + ']';\n}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\n\ndefineToStringTag(GraphQLList);\ndefineToJSON(GraphQLList);\n/**\n * Non-Null Type Wrapper\n *\n * A non-null is a wrapping type which points to another type.\n * Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n *     const RowType = new GraphQLObjectType({\n *       name: 'Row',\n *       fields: () => ({\n *         id: { type: GraphQLNonNull(GraphQLString) },\n *       })\n *     })\n *\n * Note: the enforcement of non-nullability occurs within the executor.\n */\n// eslint-disable-next-line no-redeclare\n\nexport function GraphQLNonNull(ofType) {\n  if (this instanceof GraphQLNonNull) {\n    this.ofType = assertNullableType(ofType);\n  } else {\n    return new GraphQLNonNull(ofType);\n  }\n} // Need to cast through any to alter the prototype.\n\nGraphQLNonNull.prototype.toString = function toString() {\n  return String(this.ofType) + '!';\n}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\n\ndefineToStringTag(GraphQLNonNull);\ndefineToJSON(GraphQLNonNull);\n/**\n * These types wrap and modify other types\n */\n\nexport function isWrappingType(type) {\n  return isListType(type) || isNonNullType(type);\n}\nexport function assertWrappingType(type) {\n  if (!isWrappingType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL wrapping type.\"));\n  }\n\n  return type;\n}\n/**\n * These types can all accept null as a value.\n */\n\nexport function isNullableType(type) {\n  return isType(type) && !isNonNullType(type);\n}\nexport function assertNullableType(type) {\n  if (!isNullableType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL nullable type.\"));\n  }\n\n  return type;\n}\n/* eslint-disable no-redeclare */\n\nexport function getNullableType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    return isNonNullType(type) ? type.ofType : type;\n  }\n}\n/**\n * These named types do not include modifiers like List or NonNull.\n */\n\nexport function isNamedType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);\n}\nexport function assertNamedType(type) {\n  if (!isNamedType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL named type.\"));\n  }\n\n  return type;\n}\n/* eslint-disable no-redeclare */\n\nexport function getNamedType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    var unwrappedType = type;\n\n    while (isWrappingType(unwrappedType)) {\n      unwrappedType = unwrappedType.ofType;\n    }\n\n    return unwrappedType;\n  }\n}\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\n\nfunction resolveThunk(thunk) {\n  // $FlowFixMe(>=0.90.0)\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n\nfunction undefineIfEmpty(arr) {\n  return arr && arr.length > 0 ? arr : undefined;\n}\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's serialize function does not return a value (i.e. it returns\n * `undefined`) then an error will be raised and a `null` value will be returned\n * in the response. If the serialize function returns `null`, then no error will\n * be included in the response.\n *\n * Example:\n *\n *     const OddType = new GraphQLScalarType({\n *       name: 'Odd',\n *       serialize(value) {\n *         if (value % 2 === 1) {\n *           return value;\n *         }\n *       }\n *     });\n *\n */\n\n\nexport var GraphQLScalarType = /*#__PURE__*/function () {\n  function GraphQLScalarType(config) {\n    var parseValue = config.parseValue || identityFunc;\n    this.name = config.name;\n    this.description = config.description;\n    this.serialize = config.serialize || identityFunc;\n    this.parseValue = parseValue;\n\n    this.parseLiteral = config.parseLiteral || function (node) {\n      return parseValue(valueFromASTUntyped(node));\n    };\n\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.serialize == null || typeof config.serialize === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"serialize\\\" function. If this custom Scalar is also used as an input type, ensure \\\"parseValue\\\" and \\\"parseLiteral\\\" functions are also provided.\"));\n\n    if (config.parseLiteral) {\n      typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function' || devAssert(0, \"\".concat(this.name, \" must provide both \\\"parseValue\\\" and \\\"parseLiteral\\\" functions.\"));\n    }\n  }\n\n  var _proto = GraphQLScalarType.prototype;\n\n  _proto.toConfig = function toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      serialize: this.serialize,\n      parseValue: this.parseValue,\n      parseLiteral: this.parseLiteral,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLScalarType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLScalarType);\ndefineToJSON(GraphQLScalarType);\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n *     const AddressType = new GraphQLObjectType({\n *       name: 'Address',\n *       fields: {\n *         street: { type: GraphQLString },\n *         number: { type: GraphQLInt },\n *         formatted: {\n *           type: GraphQLString,\n *           resolve(obj) {\n *             return obj.number + ' ' + obj.street\n *           }\n *         }\n *       }\n *     });\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         name: { type: GraphQLString },\n *         bestFriend: { type: PersonType },\n *       })\n *     });\n *\n */\n\nexport var GraphQLObjectType = /*#__PURE__*/function () {\n  function GraphQLObjectType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.isTypeOf = config.isTypeOf;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._fields = defineFieldMap.bind(undefined, config);\n    this._interfaces = defineInterfaces.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.isTypeOf == null || typeof config.isTypeOf === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"isTypeOf\\\" as a function, \") + \"but got: \".concat(inspect(config.isTypeOf), \".\"));\n  }\n\n  var _proto2 = GraphQLObjectType.prototype;\n\n  _proto2.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto2.getInterfaces = function getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  };\n\n  _proto2.toConfig = function toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      isTypeOf: this.isTypeOf,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto2.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLObjectType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLObjectType);\ndefineToJSON(GraphQLObjectType);\n\nfunction defineInterfaces(config) {\n  var interfaces = resolveThunk(config.interfaces) || [];\n  Array.isArray(interfaces) || devAssert(0, \"\".concat(config.name, \" interfaces must be an Array or a function which returns an Array.\"));\n  return interfaces;\n}\n\nfunction defineFieldMap(config) {\n  var fieldMap = resolveThunk(config.fields) || {};\n  isPlainObj(fieldMap) || devAssert(0, \"\".concat(config.name, \" fields must be an object with field names as keys or a function which returns such an object.\"));\n  return mapValue(fieldMap, function (fieldConfig, fieldName) {\n    isPlainObj(fieldConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" field config must be an object\"));\n    !('isDeprecated' in fieldConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" should provide \\\"deprecationReason\\\" instead of \\\"isDeprecated\\\".\"));\n    fieldConfig.resolve == null || typeof fieldConfig.resolve === 'function' || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" field resolver must be a function if \") + \"provided, but got: \".concat(inspect(fieldConfig.resolve), \".\"));\n    var argsConfig = fieldConfig.args || {};\n    isPlainObj(argsConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" args must be an object with argument names as keys.\"));\n    var args = objectEntries(argsConfig).map(function (_ref) {\n      var argName = _ref[0],\n          arg = _ref[1];\n      return {\n        name: argName,\n        description: arg.description === undefined ? null : arg.description,\n        type: arg.type,\n        defaultValue: arg.defaultValue,\n        extensions: arg.extensions && toObjMap(arg.extensions),\n        astNode: arg.astNode\n      };\n    });\n    return _objectSpread({}, fieldConfig, {\n      name: fieldName,\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      args: args,\n      resolve: fieldConfig.resolve,\n      subscribe: fieldConfig.subscribe,\n      isDeprecated: Boolean(fieldConfig.deprecationReason),\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: fieldConfig.extensions && toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    });\n  });\n}\n\nfunction isPlainObj(obj) {\n  return isObjectLike(obj) && !Array.isArray(obj);\n}\n\nfunction fieldsToFieldsConfig(fields) {\n  return mapValue(fields, function (field) {\n    return {\n      description: field.description,\n      type: field.type,\n      args: argsToArgsConfig(field.args),\n      resolve: field.resolve,\n      subscribe: field.subscribe,\n      deprecationReason: field.deprecationReason,\n      extensions: field.extensions,\n      astNode: field.astNode\n    };\n  });\n}\n\nexport function argsToArgsConfig(args) {\n  return keyValMap(args, function (arg) {\n    return arg.name;\n  }, function (arg) {\n    return {\n      description: arg.description,\n      type: arg.type,\n      defaultValue: arg.defaultValue,\n      extensions: arg.extensions,\n      astNode: arg.astNode\n    };\n  });\n}\nexport function isRequiredArgument(arg) {\n  return isNonNullType(arg.type) && arg.defaultValue === undefined;\n}\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n *     const EntityType = new GraphQLInterfaceType({\n *       name: 'Entity',\n *       fields: {\n *         name: { type: GraphQLString }\n *       }\n *     });\n *\n */\n\nexport var GraphQLInterfaceType = /*#__PURE__*/function () {\n  function GraphQLInterfaceType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._fields = defineFieldMap.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.resolveType == null || typeof config.resolveType === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"resolveType\\\" as a function, \") + \"but got: \".concat(inspect(config.resolveType), \".\"));\n  }\n\n  var _proto3 = GraphQLInterfaceType.prototype;\n\n  _proto3.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto3.toConfig = function toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      fields: fieldsToFieldsConfig(this.getFields()),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto3.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInterfaceType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLInterfaceType);\ndefineToJSON(GraphQLInterfaceType);\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n *     const PetType = new GraphQLUnionType({\n *       name: 'Pet',\n *       types: [ DogType, CatType ],\n *       resolveType(value) {\n *         if (value instanceof Dog) {\n *           return DogType;\n *         }\n *         if (value instanceof Cat) {\n *           return CatType;\n *         }\n *       }\n *     });\n *\n */\n\nexport var GraphQLUnionType = /*#__PURE__*/function () {\n  function GraphQLUnionType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._types = defineTypes.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.resolveType == null || typeof config.resolveType === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"resolveType\\\" as a function, \") + \"but got: \".concat(inspect(config.resolveType), \".\"));\n  }\n\n  var _proto4 = GraphQLUnionType.prototype;\n\n  _proto4.getTypes = function getTypes() {\n    if (typeof this._types === 'function') {\n      this._types = this._types();\n    }\n\n    return this._types;\n  };\n\n  _proto4.toConfig = function toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      types: this.getTypes(),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto4.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLUnionType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLUnionType);\ndefineToJSON(GraphQLUnionType);\n\nfunction defineTypes(config) {\n  var types = resolveThunk(config.types) || [];\n  Array.isArray(types) || devAssert(0, \"Must provide Array of types or a function which returns such an array for Union \".concat(config.name, \".\"));\n  return types;\n}\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n *     const RGBType = new GraphQLEnumType({\n *       name: 'RGB',\n *       values: {\n *         RED: { value: 0 },\n *         GREEN: { value: 1 },\n *         BLUE: { value: 2 }\n *       }\n *     });\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\n\n\nexport var GraphQLEnumType\n/* <T> */\n= /*#__PURE__*/function () {\n  function GraphQLEnumType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._values = defineEnumValues(this.name, config.values);\n    this._valueLookup = new Map(this._values.map(function (enumValue) {\n      return [enumValue.value, enumValue];\n    }));\n    this._nameLookup = keyMap(this._values, function (value) {\n      return value.name;\n    });\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n  }\n\n  var _proto5 = GraphQLEnumType.prototype;\n\n  _proto5.getValues = function getValues() {\n    return this._values;\n  };\n\n  _proto5.getValue = function getValue(name) {\n    return this._nameLookup[name];\n  };\n\n  _proto5.serialize = function serialize(value) {\n    var enumValue = this._valueLookup.get(value);\n\n    if (enumValue) {\n      return enumValue.name;\n    }\n  };\n\n  _proto5.parseValue = function parseValue(value)\n  /* T */\n  {\n    if (typeof value === 'string') {\n      var enumValue = this.getValue(value);\n\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  _proto5.parseLiteral = function parseLiteral(valueNode, _variables)\n  /* T */\n  {\n    // Note: variables will be resolved to a value before calling this function.\n    if (valueNode.kind === Kind.ENUM) {\n      var enumValue = this.getValue(valueNode.value);\n\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  _proto5.toConfig = function toConfig() {\n    var values = keyValMap(this.getValues(), function (value) {\n      return value.name;\n    }, function (value) {\n      return {\n        description: value.description,\n        value: value.value,\n        deprecationReason: value.deprecationReason,\n        extensions: value.extensions,\n        astNode: value.astNode\n      };\n    });\n    return {\n      name: this.name,\n      description: this.description,\n      values: values,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto5.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLEnumType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLEnumType);\ndefineToJSON(GraphQLEnumType);\n\nfunction defineEnumValues(typeName, valueMap) {\n  isPlainObj(valueMap) || devAssert(0, \"\".concat(typeName, \" values must be an object with value names as keys.\"));\n  return objectEntries(valueMap).map(function (_ref2) {\n    var valueName = _ref2[0],\n        value = _ref2[1];\n    isPlainObj(value) || devAssert(0, \"\".concat(typeName, \".\").concat(valueName, \" must refer to an object with a \\\"value\\\" key \") + \"representing an internal value but got: \".concat(inspect(value), \".\"));\n    !('isDeprecated' in value) || devAssert(0, \"\".concat(typeName, \".\").concat(valueName, \" should provide \\\"deprecationReason\\\" instead of \\\"isDeprecated\\\".\"));\n    return {\n      name: valueName,\n      description: value.description,\n      value: 'value' in value ? value.value : valueName,\n      isDeprecated: Boolean(value.deprecationReason),\n      deprecationReason: value.deprecationReason,\n      extensions: value.extensions && toObjMap(value.extensions),\n      astNode: value.astNode\n    };\n  });\n}\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n *     const GeoPoint = new GraphQLInputObjectType({\n *       name: 'GeoPoint',\n *       fields: {\n *         lat: { type: GraphQLNonNull(GraphQLFloat) },\n *         lon: { type: GraphQLNonNull(GraphQLFloat) },\n *         alt: { type: GraphQLFloat, defaultValue: 0 },\n *       }\n *     });\n *\n */\n\n\nexport var GraphQLInputObjectType = /*#__PURE__*/function () {\n  function GraphQLInputObjectType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._fields = defineInputFieldMap.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n  }\n\n  var _proto6 = GraphQLInputObjectType.prototype;\n\n  _proto6.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto6.toConfig = function toConfig() {\n    var fields = mapValue(this.getFields(), function (field) {\n      return {\n        description: field.description,\n        type: field.type,\n        defaultValue: field.defaultValue,\n        extensions: field.extensions,\n        astNode: field.astNode\n      };\n    });\n    return {\n      name: this.name,\n      description: this.description,\n      fields: fields,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto6.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInputObjectType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLInputObjectType);\ndefineToJSON(GraphQLInputObjectType);\n\nfunction defineInputFieldMap(config) {\n  var fieldMap = resolveThunk(config.fields) || {};\n  isPlainObj(fieldMap) || devAssert(0, \"\".concat(config.name, \" fields must be an object with field names as keys or a function which returns such an object.\"));\n  return mapValue(fieldMap, function (fieldConfig, fieldName) {\n    !('resolve' in fieldConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" field has a resolve property, but Input Types cannot define resolvers.\"));\n    return _objectSpread({}, fieldConfig, {\n      name: fieldName,\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      defaultValue: fieldConfig.defaultValue,\n      extensions: fieldConfig.extensions && toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    });\n  });\n}\n\nexport function isRequiredInputField(field) {\n  return isNonNullType(field.type) && field.defaultValue === undefined;\n}","map":{"version":3,"sources":["H:/Programming Repositories/Titans/Web/UpSkill.Web/ClientApp/node_modules/graphql/type/definition.mjs"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","objectEntries","inspect","keyMap","mapValue","toObjMap","devAssert","keyValMap","instanceOf","isObjectLike","identityFunc","defineToJSON","defineToStringTag","Kind","valueFromASTUntyped","isType","type","isScalarType","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isListType","isNonNullType","assertType","Error","concat","GraphQLScalarType","assertScalarType","GraphQLObjectType","assertObjectType","GraphQLInterfaceType","assertInterfaceType","GraphQLUnionType","assertUnionType","GraphQLEnumType","assertEnumType","GraphQLInputObjectType","assertInputObjectType","GraphQLList","assertListType","GraphQLNonNull","assertNonNullType","isInputType","isWrappingType","ofType","assertInputType","isOutputType","assertOutputType","isLeafType","assertLeafType","isCompositeType","assertCompositeType","isAbstractType","assertAbstractType","prototype","toString","String","assertNullableType","assertWrappingType","isNullableType","getNullableType","isNamedType","assertNamedType","getNamedType","unwrappedType","resolveThunk","thunk","undefineIfEmpty","arr","undefined","config","parseValue","name","description","serialize","parseLiteral","node","extensions","astNode","extensionASTNodes","_proto","toConfig","isTypeOf","_fields","defineFieldMap","bind","_interfaces","defineInterfaces","_proto2","getFields","getInterfaces","interfaces","fields","fieldsToFieldsConfig","Array","isArray","fieldMap","isPlainObj","fieldConfig","fieldName","resolve","argsConfig","args","map","_ref","argName","arg","defaultValue","subscribe","isDeprecated","Boolean","deprecationReason","field","argsToArgsConfig","isRequiredArgument","resolveType","_proto3","_types","defineTypes","_proto4","getTypes","types","_values","defineEnumValues","values","_valueLookup","Map","enumValue","_nameLookup","_proto5","getValues","getValue","get","valueNode","_variables","kind","ENUM","typeName","valueMap","_ref2","valueName","defineInputFieldMap","_proto6","isRequiredInputField"],"mappings":"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","sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport objectEntries from '../polyfills/objectEntries';\nimport inspect from '../jsutils/inspect';\nimport keyMap from '../jsutils/keyMap';\nimport mapValue from '../jsutils/mapValue';\nimport toObjMap from '../jsutils/toObjMap';\nimport devAssert from '../jsutils/devAssert';\nimport keyValMap from '../jsutils/keyValMap';\nimport instanceOf from '../jsutils/instanceOf';\nimport isObjectLike from '../jsutils/isObjectLike';\nimport identityFunc from '../jsutils/identityFunc';\nimport defineToJSON from '../jsutils/defineToJSON';\nimport defineToStringTag from '../jsutils/defineToStringTag';\nimport { Kind } from '../language/kinds';\nimport { valueFromASTUntyped } from '../utilities/valueFromASTUntyped';\nexport function isType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);\n}\nexport function assertType(type) {\n  if (!isType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL type.\"));\n  }\n\n  return type;\n}\n/**\n * There are predicates for each kind of GraphQL type.\n */\n\n// eslint-disable-next-line no-redeclare\nexport function isScalarType(type) {\n  return instanceOf(type, GraphQLScalarType);\n}\nexport function assertScalarType(type) {\n  if (!isScalarType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Scalar type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isObjectType(type) {\n  return instanceOf(type, GraphQLObjectType);\n}\nexport function assertObjectType(type) {\n  if (!isObjectType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Object type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isInterfaceType(type) {\n  return instanceOf(type, GraphQLInterfaceType);\n}\nexport function assertInterfaceType(type) {\n  if (!isInterfaceType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Interface type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isUnionType(type) {\n  return instanceOf(type, GraphQLUnionType);\n}\nexport function assertUnionType(type) {\n  if (!isUnionType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Union type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isEnumType(type) {\n  return instanceOf(type, GraphQLEnumType);\n}\nexport function assertEnumType(type) {\n  if (!isEnumType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Enum type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isInputObjectType(type) {\n  return instanceOf(type, GraphQLInputObjectType);\n}\nexport function assertInputObjectType(type) {\n  if (!isInputObjectType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Input Object type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isListType(type) {\n  return instanceOf(type, GraphQLList);\n}\nexport function assertListType(type) {\n  if (!isListType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL List type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isNonNullType(type) {\n  return instanceOf(type, GraphQLNonNull);\n}\nexport function assertNonNullType(type) {\n  if (!isNonNullType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Non-Null type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may be used as input types for arguments and directives.\n */\n\nexport function isInputType(type) {\n  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);\n}\nexport function assertInputType(type) {\n  if (!isInputType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL input type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may be used as output types as the result of fields.\n */\n\nexport function isOutputType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);\n}\nexport function assertOutputType(type) {\n  if (!isOutputType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL output type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may describe types which may be leaf values.\n */\n\nexport function isLeafType(type) {\n  return isScalarType(type) || isEnumType(type);\n}\nexport function assertLeafType(type) {\n  if (!isLeafType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL leaf type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isCompositeType(type) {\n  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);\n}\nexport function assertCompositeType(type) {\n  if (!isCompositeType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL composite type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isAbstractType(type) {\n  return isInterfaceType(type) || isUnionType(type);\n}\nexport function assertAbstractType(type) {\n  if (!isAbstractType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL abstract type.\"));\n  }\n\n  return type;\n}\n/**\n * List Type Wrapper\n *\n * A list is a wrapping type which points to another type.\n * Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         parents: { type: GraphQLList(PersonType) },\n *         children: { type: GraphQLList(PersonType) },\n *       })\n *     })\n *\n */\n\n// eslint-disable-next-line no-redeclare\nexport function GraphQLList(ofType) {\n  if (this instanceof GraphQLList) {\n    this.ofType = assertType(ofType);\n  } else {\n    return new GraphQLList(ofType);\n  }\n} // Need to cast through any to alter the prototype.\n\nGraphQLList.prototype.toString = function toString() {\n  return '[' + String(this.ofType) + ']';\n}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\n\ndefineToStringTag(GraphQLList);\ndefineToJSON(GraphQLList);\n/**\n * Non-Null Type Wrapper\n *\n * A non-null is a wrapping type which points to another type.\n * Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n *     const RowType = new GraphQLObjectType({\n *       name: 'Row',\n *       fields: () => ({\n *         id: { type: GraphQLNonNull(GraphQLString) },\n *       })\n *     })\n *\n * Note: the enforcement of non-nullability occurs within the executor.\n */\n\n// eslint-disable-next-line no-redeclare\nexport function GraphQLNonNull(ofType) {\n  if (this instanceof GraphQLNonNull) {\n    this.ofType = assertNullableType(ofType);\n  } else {\n    return new GraphQLNonNull(ofType);\n  }\n} // Need to cast through any to alter the prototype.\n\nGraphQLNonNull.prototype.toString = function toString() {\n  return String(this.ofType) + '!';\n}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\n\ndefineToStringTag(GraphQLNonNull);\ndefineToJSON(GraphQLNonNull);\n/**\n * These types wrap and modify other types\n */\n\nexport function isWrappingType(type) {\n  return isListType(type) || isNonNullType(type);\n}\nexport function assertWrappingType(type) {\n  if (!isWrappingType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL wrapping type.\"));\n  }\n\n  return type;\n}\n/**\n * These types can all accept null as a value.\n */\n\nexport function isNullableType(type) {\n  return isType(type) && !isNonNullType(type);\n}\nexport function assertNullableType(type) {\n  if (!isNullableType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL nullable type.\"));\n  }\n\n  return type;\n}\n/* eslint-disable no-redeclare */\n\nexport function getNullableType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    return isNonNullType(type) ? type.ofType : type;\n  }\n}\n/**\n * These named types do not include modifiers like List or NonNull.\n */\n\nexport function isNamedType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);\n}\nexport function assertNamedType(type) {\n  if (!isNamedType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL named type.\"));\n  }\n\n  return type;\n}\n/* eslint-disable no-redeclare */\n\nexport function getNamedType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    var unwrappedType = type;\n\n    while (isWrappingType(unwrappedType)) {\n      unwrappedType = unwrappedType.ofType;\n    }\n\n    return unwrappedType;\n  }\n}\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\n\nfunction resolveThunk(thunk) {\n  // $FlowFixMe(>=0.90.0)\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n\nfunction undefineIfEmpty(arr) {\n  return arr && arr.length > 0 ? arr : undefined;\n}\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's serialize function does not return a value (i.e. it returns\n * `undefined`) then an error will be raised and a `null` value will be returned\n * in the response. If the serialize function returns `null`, then no error will\n * be included in the response.\n *\n * Example:\n *\n *     const OddType = new GraphQLScalarType({\n *       name: 'Odd',\n *       serialize(value) {\n *         if (value % 2 === 1) {\n *           return value;\n *         }\n *       }\n *     });\n *\n */\n\n\nexport var GraphQLScalarType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLScalarType(config) {\n    var parseValue = config.parseValue || identityFunc;\n    this.name = config.name;\n    this.description = config.description;\n    this.serialize = config.serialize || identityFunc;\n    this.parseValue = parseValue;\n\n    this.parseLiteral = config.parseLiteral || function (node) {\n      return parseValue(valueFromASTUntyped(node));\n    };\n\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.serialize == null || typeof config.serialize === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"serialize\\\" function. If this custom Scalar is also used as an input type, ensure \\\"parseValue\\\" and \\\"parseLiteral\\\" functions are also provided.\"));\n\n    if (config.parseLiteral) {\n      typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function' || devAssert(0, \"\".concat(this.name, \" must provide both \\\"parseValue\\\" and \\\"parseLiteral\\\" functions.\"));\n    }\n  }\n\n  var _proto = GraphQLScalarType.prototype;\n\n  _proto.toConfig = function toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      serialize: this.serialize,\n      parseValue: this.parseValue,\n      parseLiteral: this.parseLiteral,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLScalarType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLScalarType);\ndefineToJSON(GraphQLScalarType);\n\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n *     const AddressType = new GraphQLObjectType({\n *       name: 'Address',\n *       fields: {\n *         street: { type: GraphQLString },\n *         number: { type: GraphQLInt },\n *         formatted: {\n *           type: GraphQLString,\n *           resolve(obj) {\n *             return obj.number + ' ' + obj.street\n *           }\n *         }\n *       }\n *     });\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         name: { type: GraphQLString },\n *         bestFriend: { type: PersonType },\n *       })\n *     });\n *\n */\nexport var GraphQLObjectType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLObjectType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.isTypeOf = config.isTypeOf;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._fields = defineFieldMap.bind(undefined, config);\n    this._interfaces = defineInterfaces.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.isTypeOf == null || typeof config.isTypeOf === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"isTypeOf\\\" as a function, \") + \"but got: \".concat(inspect(config.isTypeOf), \".\"));\n  }\n\n  var _proto2 = GraphQLObjectType.prototype;\n\n  _proto2.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto2.getInterfaces = function getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  };\n\n  _proto2.toConfig = function toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      isTypeOf: this.isTypeOf,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto2.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLObjectType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLObjectType);\ndefineToJSON(GraphQLObjectType);\n\nfunction defineInterfaces(config) {\n  var interfaces = resolveThunk(config.interfaces) || [];\n  Array.isArray(interfaces) || devAssert(0, \"\".concat(config.name, \" interfaces must be an Array or a function which returns an Array.\"));\n  return interfaces;\n}\n\nfunction defineFieldMap(config) {\n  var fieldMap = resolveThunk(config.fields) || {};\n  isPlainObj(fieldMap) || devAssert(0, \"\".concat(config.name, \" fields must be an object with field names as keys or a function which returns such an object.\"));\n  return mapValue(fieldMap, function (fieldConfig, fieldName) {\n    isPlainObj(fieldConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" field config must be an object\"));\n    !('isDeprecated' in fieldConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" should provide \\\"deprecationReason\\\" instead of \\\"isDeprecated\\\".\"));\n    fieldConfig.resolve == null || typeof fieldConfig.resolve === 'function' || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" field resolver must be a function if \") + \"provided, but got: \".concat(inspect(fieldConfig.resolve), \".\"));\n    var argsConfig = fieldConfig.args || {};\n    isPlainObj(argsConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" args must be an object with argument names as keys.\"));\n    var args = objectEntries(argsConfig).map(function (_ref) {\n      var argName = _ref[0],\n          arg = _ref[1];\n      return {\n        name: argName,\n        description: arg.description === undefined ? null : arg.description,\n        type: arg.type,\n        defaultValue: arg.defaultValue,\n        extensions: arg.extensions && toObjMap(arg.extensions),\n        astNode: arg.astNode\n      };\n    });\n    return _objectSpread({}, fieldConfig, {\n      name: fieldName,\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      args: args,\n      resolve: fieldConfig.resolve,\n      subscribe: fieldConfig.subscribe,\n      isDeprecated: Boolean(fieldConfig.deprecationReason),\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: fieldConfig.extensions && toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    });\n  });\n}\n\nfunction isPlainObj(obj) {\n  return isObjectLike(obj) && !Array.isArray(obj);\n}\n\nfunction fieldsToFieldsConfig(fields) {\n  return mapValue(fields, function (field) {\n    return {\n      description: field.description,\n      type: field.type,\n      args: argsToArgsConfig(field.args),\n      resolve: field.resolve,\n      subscribe: field.subscribe,\n      deprecationReason: field.deprecationReason,\n      extensions: field.extensions,\n      astNode: field.astNode\n    };\n  });\n}\n\nexport function argsToArgsConfig(args) {\n  return keyValMap(args, function (arg) {\n    return arg.name;\n  }, function (arg) {\n    return {\n      description: arg.description,\n      type: arg.type,\n      defaultValue: arg.defaultValue,\n      extensions: arg.extensions,\n      astNode: arg.astNode\n    };\n  });\n}\nexport function isRequiredArgument(arg) {\n  return isNonNullType(arg.type) && arg.defaultValue === undefined;\n}\n\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n *     const EntityType = new GraphQLInterfaceType({\n *       name: 'Entity',\n *       fields: {\n *         name: { type: GraphQLString }\n *       }\n *     });\n *\n */\nexport var GraphQLInterfaceType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLInterfaceType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._fields = defineFieldMap.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.resolveType == null || typeof config.resolveType === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"resolveType\\\" as a function, \") + \"but got: \".concat(inspect(config.resolveType), \".\"));\n  }\n\n  var _proto3 = GraphQLInterfaceType.prototype;\n\n  _proto3.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto3.toConfig = function toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      fields: fieldsToFieldsConfig(this.getFields()),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto3.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInterfaceType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLInterfaceType);\ndefineToJSON(GraphQLInterfaceType);\n\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n *     const PetType = new GraphQLUnionType({\n *       name: 'Pet',\n *       types: [ DogType, CatType ],\n *       resolveType(value) {\n *         if (value instanceof Dog) {\n *           return DogType;\n *         }\n *         if (value instanceof Cat) {\n *           return CatType;\n *         }\n *       }\n *     });\n *\n */\nexport var GraphQLUnionType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLUnionType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._types = defineTypes.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.resolveType == null || typeof config.resolveType === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"resolveType\\\" as a function, \") + \"but got: \".concat(inspect(config.resolveType), \".\"));\n  }\n\n  var _proto4 = GraphQLUnionType.prototype;\n\n  _proto4.getTypes = function getTypes() {\n    if (typeof this._types === 'function') {\n      this._types = this._types();\n    }\n\n    return this._types;\n  };\n\n  _proto4.toConfig = function toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      types: this.getTypes(),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto4.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLUnionType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLUnionType);\ndefineToJSON(GraphQLUnionType);\n\nfunction defineTypes(config) {\n  var types = resolveThunk(config.types) || [];\n  Array.isArray(types) || devAssert(0, \"Must provide Array of types or a function which returns such an array for Union \".concat(config.name, \".\"));\n  return types;\n}\n\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n *     const RGBType = new GraphQLEnumType({\n *       name: 'RGB',\n *       values: {\n *         RED: { value: 0 },\n *         GREEN: { value: 1 },\n *         BLUE: { value: 2 }\n *       }\n *     });\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\nexport var GraphQLEnumType\n/* <T> */\n=\n/*#__PURE__*/\nfunction () {\n  function GraphQLEnumType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._values = defineEnumValues(this.name, config.values);\n    this._valueLookup = new Map(this._values.map(function (enumValue) {\n      return [enumValue.value, enumValue];\n    }));\n    this._nameLookup = keyMap(this._values, function (value) {\n      return value.name;\n    });\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n  }\n\n  var _proto5 = GraphQLEnumType.prototype;\n\n  _proto5.getValues = function getValues() {\n    return this._values;\n  };\n\n  _proto5.getValue = function getValue(name) {\n    return this._nameLookup[name];\n  };\n\n  _proto5.serialize = function serialize(value) {\n    var enumValue = this._valueLookup.get(value);\n\n    if (enumValue) {\n      return enumValue.name;\n    }\n  };\n\n  _proto5.parseValue = function parseValue(value)\n  /* T */\n  {\n    if (typeof value === 'string') {\n      var enumValue = this.getValue(value);\n\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  _proto5.parseLiteral = function parseLiteral(valueNode, _variables)\n  /* T */\n  {\n    // Note: variables will be resolved to a value before calling this function.\n    if (valueNode.kind === Kind.ENUM) {\n      var enumValue = this.getValue(valueNode.value);\n\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  _proto5.toConfig = function toConfig() {\n    var values = keyValMap(this.getValues(), function (value) {\n      return value.name;\n    }, function (value) {\n      return {\n        description: value.description,\n        value: value.value,\n        deprecationReason: value.deprecationReason,\n        extensions: value.extensions,\n        astNode: value.astNode\n      };\n    });\n    return {\n      name: this.name,\n      description: this.description,\n      values: values,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto5.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLEnumType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLEnumType);\ndefineToJSON(GraphQLEnumType);\n\nfunction defineEnumValues(typeName, valueMap) {\n  isPlainObj(valueMap) || devAssert(0, \"\".concat(typeName, \" values must be an object with value names as keys.\"));\n  return objectEntries(valueMap).map(function (_ref2) {\n    var valueName = _ref2[0],\n        value = _ref2[1];\n    isPlainObj(value) || devAssert(0, \"\".concat(typeName, \".\").concat(valueName, \" must refer to an object with a \\\"value\\\" key \") + \"representing an internal value but got: \".concat(inspect(value), \".\"));\n    !('isDeprecated' in value) || devAssert(0, \"\".concat(typeName, \".\").concat(valueName, \" should provide \\\"deprecationReason\\\" instead of \\\"isDeprecated\\\".\"));\n    return {\n      name: valueName,\n      description: value.description,\n      value: 'value' in value ? value.value : valueName,\n      isDeprecated: Boolean(value.deprecationReason),\n      deprecationReason: value.deprecationReason,\n      extensions: value.extensions && toObjMap(value.extensions),\n      astNode: value.astNode\n    };\n  });\n}\n\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n *     const GeoPoint = new GraphQLInputObjectType({\n *       name: 'GeoPoint',\n *       fields: {\n *         lat: { type: GraphQLNonNull(GraphQLFloat) },\n *         lon: { type: GraphQLNonNull(GraphQLFloat) },\n *         alt: { type: GraphQLFloat, defaultValue: 0 },\n *       }\n *     });\n *\n */\nexport var GraphQLInputObjectType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLInputObjectType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._fields = defineInputFieldMap.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n  }\n\n  var _proto6 = GraphQLInputObjectType.prototype;\n\n  _proto6.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto6.toConfig = function toConfig() {\n    var fields = mapValue(this.getFields(), function (field) {\n      return {\n        description: field.description,\n        type: field.type,\n        defaultValue: field.defaultValue,\n        extensions: field.extensions,\n        astNode: field.astNode\n      };\n    });\n    return {\n      name: this.name,\n      description: this.description,\n      fields: fields,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto6.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInputObjectType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLInputObjectType);\ndefineToJSON(GraphQLInputObjectType);\n\nfunction defineInputFieldMap(config) {\n  var fieldMap = resolveThunk(config.fields) || {};\n  isPlainObj(fieldMap) || devAssert(0, \"\".concat(config.name, \" fields must be an object with field names as keys or a function which returns such an object.\"));\n  return mapValue(fieldMap, function (fieldConfig, fieldName) {\n    !('resolve' in fieldConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" field has a resolve property, but Input Types cannot define resolvers.\"));\n    return _objectSpread({}, fieldConfig, {\n      name: fieldName,\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      defaultValue: fieldConfig.defaultValue,\n      extensions: fieldConfig.extensions && toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    });\n  });\n}\n\nexport function isRequiredInputField(field) {\n  return isNonNullType(field.type) && field.defaultValue === undefined;\n}\n"]},"metadata":{},"sourceType":"module"}