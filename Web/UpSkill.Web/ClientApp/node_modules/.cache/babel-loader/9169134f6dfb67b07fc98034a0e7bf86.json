{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UniqueTypeNamesWithFields = exports.existedTypeNameMessage = exports.duplicateTypeNameMessage = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst utils_1 = require(\"../../utils\");\n\nfunction duplicateTypeNameMessage(typeName) {\n  return `There can be only one type named \"${typeName}\".`;\n}\n\nexports.duplicateTypeNameMessage = duplicateTypeNameMessage;\n\nfunction existedTypeNameMessage(typeName) {\n  return `Type \"${typeName}\" already exists in the schema. It cannot also be defined in this type definition.`;\n}\n\nexports.existedTypeNameMessage = existedTypeNameMessage;\n\nfunction UniqueTypeNamesWithFields(context) {\n  const knownTypes = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    ScalarTypeDefinition: checkTypeName,\n    ObjectTypeDefinition: checkTypeName,\n    InterfaceTypeDefinition: checkTypeName,\n    UnionTypeDefinition: checkTypeName,\n    EnumTypeDefinition: checkTypeName,\n    InputObjectTypeDefinition: checkTypeName\n  };\n\n  function checkTypeName(node) {\n    const typeName = node.name.value;\n    const typeFromSchema = schema && schema.getType(typeName);\n    const typeNodeFromSchema = typeFromSchema && typeFromSchema.astNode;\n    const typeNodeFromDefs = knownTypes[typeName];\n    const duplicateTypeNode = typeNodeFromSchema || typeNodeFromDefs;\n\n    if (duplicateTypeNode) {\n      const possibleErrors = [];\n      const {\n        kind,\n        fields,\n        inputValues\n      } = utils_1.diffTypeNodes(node, duplicateTypeNode);\n      const fieldsDiff = Object.entries(fields);\n\n      if (kind.length > 0) {\n        context.reportError(utils_1.errorWithCode('VALUE_TYPE_KIND_MISMATCH', `${utils_1.logServiceAndType(duplicateTypeNode.serviceName, typeName)}Found kind mismatch on expected value type belonging to services \\`${duplicateTypeNode.serviceName}\\` and \\`${node.serviceName}\\`. \\`${typeName}\\` is defined as both a \\`${kind[0]}\\` and a \\`${kind[1]}\\`. In order to define \\`${typeName}\\` in multiple places, the kinds must be identical.`, [node, duplicateTypeNode]));\n        return;\n      }\n\n      const typesHaveSameFieldShape = fieldsDiff.length === 0 || fieldsDiff.every(([fieldName, types]) => {\n        var _a, _b;\n\n        if (types.length === 2) {\n          const fieldNode = 'fields' in node && ((_a = node.fields) === null || _a === void 0 ? void 0 : _a.find(field => field.name.value === fieldName));\n          const duplicateFieldNode = 'fields' in duplicateTypeNode && ((_b = duplicateTypeNode.fields) === null || _b === void 0 ? void 0 : _b.find(field => field.name.value === fieldName));\n          possibleErrors.push(utils_1.errorWithCode('VALUE_TYPE_FIELD_TYPE_MISMATCH', `${utils_1.logServiceAndType(duplicateTypeNode.serviceName, typeName, fieldName)}A field was defined differently in different services. \\`${duplicateTypeNode.serviceName}\\` and \\`${node.serviceName}\\` define \\`${typeName}.${fieldName}\\` as a ${types[1]} and ${types[0]} respectively. In order to define \\`${typeName}\\` in multiple places, the fields and their types must be identical.`, fieldNode && duplicateFieldNode ? [fieldNode.type, duplicateFieldNode.type] : undefined));\n          return true;\n        }\n\n        return false;\n      });\n      const inputValuesDiff = Object.entries(inputValues);\n      const typesHaveSameInputValuesShape = inputValuesDiff.length === 0 || inputValuesDiff.every(([name, types]) => {\n        if (types.length === 2) {\n          possibleErrors.push(utils_1.errorWithCode('VALUE_TYPE_INPUT_VALUE_MISMATCH', `${utils_1.logServiceAndType(duplicateTypeNode.serviceName, typeName)}A field's input type (\\`${name}\\`) was defined differently in different services. \\`${duplicateTypeNode.serviceName}\\` and \\`${node.serviceName}\\` define \\`${name}\\` as a ${types[1]} and ${types[0]} respectively. In order to define \\`${typeName}\\` in multiple places, the input values and their types must be identical.`, [node, duplicateTypeNode]));\n          return true;\n        }\n\n        return false;\n      });\n\n      if (typesHaveSameFieldShape && typesHaveSameInputValuesShape) {\n        possibleErrors.forEach(error => context.reportError(error));\n\n        if (utils_1.isTypeNodeAnEntity(node) || utils_1.isTypeNodeAnEntity(duplicateTypeNode)) {\n          const entityNode = utils_1.isTypeNodeAnEntity(duplicateTypeNode) ? duplicateTypeNode : node;\n          context.reportError(utils_1.errorWithCode('VALUE_TYPE_NO_ENTITY', `${utils_1.logServiceAndType(entityNode.serviceName, typeName)}Value types cannot be entities (using the \\`@key\\` directive). Please ensure that the \\`${typeName}\\` type is extended properly or remove the \\`@key\\` directive if this is not an entity.`, [node, duplicateTypeNode]));\n        }\n\n        return false;\n      }\n    }\n\n    if (typeFromSchema) {\n      context.reportError(new graphql_1.GraphQLError(existedTypeNameMessage(typeName), node.name));\n      return;\n    }\n\n    if (knownTypes[typeName]) {\n      context.reportError(new graphql_1.GraphQLError(duplicateTypeNameMessage(typeName), [knownTypes[typeName], node.name]));\n    } else {\n      knownTypes[typeName] = node;\n    }\n\n    return false;\n  }\n}\n\nexports.UniqueTypeNamesWithFields = UniqueTypeNamesWithFields;","map":{"version":3,"sources":["../../../../src/composition/validate/sdl/uniqueTypeNamesWithFields.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UniqueTypeNamesWithFields = exports.existedTypeNameMessage = exports.duplicateTypeNameMessage = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"../../utils\");\nfunction duplicateTypeNameMessage(typeName) {\n    return `There can be only one type named \"${typeName}\".`;\n}\nexports.duplicateTypeNameMessage = duplicateTypeNameMessage;\nfunction existedTypeNameMessage(typeName) {\n    return `Type \"${typeName}\" already exists in the schema. It cannot also be defined in this type definition.`;\n}\nexports.existedTypeNameMessage = existedTypeNameMessage;\nfunction UniqueTypeNamesWithFields(context) {\n    const knownTypes = Object.create(null);\n    const schema = context.getSchema();\n    return {\n        ScalarTypeDefinition: checkTypeName,\n        ObjectTypeDefinition: checkTypeName,\n        InterfaceTypeDefinition: checkTypeName,\n        UnionTypeDefinition: checkTypeName,\n        EnumTypeDefinition: checkTypeName,\n        InputObjectTypeDefinition: checkTypeName,\n    };\n    function checkTypeName(node) {\n        const typeName = node.name.value;\n        const typeFromSchema = schema && schema.getType(typeName);\n        const typeNodeFromSchema = typeFromSchema &&\n            typeFromSchema.astNode;\n        const typeNodeFromDefs = knownTypes[typeName];\n        const duplicateTypeNode = typeNodeFromSchema || typeNodeFromDefs;\n        if (duplicateTypeNode) {\n            const possibleErrors = [];\n            const { kind, fields, inputValues } = utils_1.diffTypeNodes(node, duplicateTypeNode);\n            const fieldsDiff = Object.entries(fields);\n            if (kind.length > 0) {\n                context.reportError(utils_1.errorWithCode('VALUE_TYPE_KIND_MISMATCH', `${utils_1.logServiceAndType(duplicateTypeNode.serviceName, typeName)}Found kind mismatch on expected value type belonging to services \\`${duplicateTypeNode.serviceName}\\` and \\`${node.serviceName}\\`. \\`${typeName}\\` is defined as both a \\`${kind[0]}\\` and a \\`${kind[1]}\\`. In order to define \\`${typeName}\\` in multiple places, the kinds must be identical.`, [node, duplicateTypeNode]));\n                return;\n            }\n            const typesHaveSameFieldShape = fieldsDiff.length === 0 ||\n                fieldsDiff.every(([fieldName, types]) => {\n                    var _a, _b;\n                    if (types.length === 2) {\n                        const fieldNode = 'fields' in node && ((_a = node.fields) === null || _a === void 0 ? void 0 : _a.find((field) => field.name.value === fieldName));\n                        const duplicateFieldNode = 'fields' in duplicateTypeNode && ((_b = duplicateTypeNode.fields) === null || _b === void 0 ? void 0 : _b.find(field => field.name.value === fieldName));\n                        possibleErrors.push(utils_1.errorWithCode('VALUE_TYPE_FIELD_TYPE_MISMATCH', `${utils_1.logServiceAndType(duplicateTypeNode.serviceName, typeName, fieldName)}A field was defined differently in different services. \\`${duplicateTypeNode.serviceName}\\` and \\`${node.serviceName}\\` define \\`${typeName}.${fieldName}\\` as a ${types[1]} and ${types[0]} respectively. In order to define \\`${typeName}\\` in multiple places, the fields and their types must be identical.`, fieldNode && duplicateFieldNode ? [fieldNode.type, duplicateFieldNode.type] : undefined));\n                        return true;\n                    }\n                    return false;\n                });\n            const inputValuesDiff = Object.entries(inputValues);\n            const typesHaveSameInputValuesShape = inputValuesDiff.length === 0 ||\n                inputValuesDiff.every(([name, types]) => {\n                    if (types.length === 2) {\n                        possibleErrors.push(utils_1.errorWithCode('VALUE_TYPE_INPUT_VALUE_MISMATCH', `${utils_1.logServiceAndType(duplicateTypeNode.serviceName, typeName)}A field's input type (\\`${name}\\`) was defined differently in different services. \\`${duplicateTypeNode.serviceName}\\` and \\`${node.serviceName}\\` define \\`${name}\\` as a ${types[1]} and ${types[0]} respectively. In order to define \\`${typeName}\\` in multiple places, the input values and their types must be identical.`, [node, duplicateTypeNode]));\n                        return true;\n                    }\n                    return false;\n                });\n            if (typesHaveSameFieldShape && typesHaveSameInputValuesShape) {\n                possibleErrors.forEach(error => context.reportError(error));\n                if (utils_1.isTypeNodeAnEntity(node) || utils_1.isTypeNodeAnEntity(duplicateTypeNode)) {\n                    const entityNode = utils_1.isTypeNodeAnEntity(duplicateTypeNode)\n                        ? duplicateTypeNode\n                        : node;\n                    context.reportError(utils_1.errorWithCode('VALUE_TYPE_NO_ENTITY', `${utils_1.logServiceAndType(entityNode.serviceName, typeName)}Value types cannot be entities (using the \\`@key\\` directive). Please ensure that the \\`${typeName}\\` type is extended properly or remove the \\`@key\\` directive if this is not an entity.`, [node, duplicateTypeNode]));\n                }\n                return false;\n            }\n        }\n        if (typeFromSchema) {\n            context.reportError(new graphql_1.GraphQLError(existedTypeNameMessage(typeName), node.name));\n            return;\n        }\n        if (knownTypes[typeName]) {\n            context.reportError(new graphql_1.GraphQLError(duplicateTypeNameMessage(typeName), [\n                knownTypes[typeName],\n                node.name,\n            ]));\n        }\n        else {\n            knownTypes[typeName] = node;\n        }\n        return false;\n    }\n}\nexports.UniqueTypeNamesWithFields = UniqueTypeNamesWithFields;\n//# sourceMappingURL=uniqueTypeNamesWithFields.js.map"]},"metadata":{},"sourceType":"script"}