{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tagDirective = void 0;\n\nconst directives_1 = require(\"../../../directives\");\n\nconst graphql_1 = require(\"graphql\");\n\nconst KnownArgumentNamesRule_1 = require(\"graphql/validation/rules/KnownArgumentNamesRule\");\n\nconst ProvidedRequiredArgumentsRule_1 = require(\"graphql/validation/rules/ProvidedRequiredArgumentsRule\");\n\nconst validate_1 = require(\"graphql/validation/validate\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst errorsMessagesToFilter = directives_1.federationDirectives.map(directive => `Unknown directive \"@${directive.name}\".`);\n\nconst tagDirective = ({\n  name: serviceName,\n  typeDefs\n}) => {\n  const directiveRules = [KnownArgumentNamesRule_1.KnownArgumentNamesOnDirectivesRule, graphql_1.KnownDirectivesRule, ProvidedRequiredArgumentsRule_1.ProvidedRequiredArgumentsOnDirectivesRule];\n  const errors = validate_1.validateSDL(typeDefs, undefined, directiveRules);\n  let tagDirectiveDefinition;\n  graphql_1.visit(typeDefs, {\n    DirectiveDefinition(node) {\n      if (node.name.value === 'tag') {\n        tagDirectiveDefinition = node;\n        return graphql_1.BREAK;\n      }\n    }\n\n  });\n\n  if (tagDirectiveDefinition) {\n    const printedTagDefinition = 'directive @tag(name: String!) repeatable on FIELD_DEFINITION';\n\n    if (graphql_1.print(utils_1.stripDescriptions(tagDirectiveDefinition)) !== printedTagDefinition) {\n      errors.push(utils_1.errorWithCode('TAG_DIRECTIVE_DEFINITION_INVALID', utils_1.logDirective('tag') + `Found @tag definition in service ${serviceName}, but the @tag directive definition was invalid. Please ensure the directive definition in your schema's type definitions matches the following:\\n\\t${printedTagDefinition}`, tagDirectiveDefinition));\n    }\n  }\n\n  return errors.filter(({\n    message\n  }) => !errorsMessagesToFilter.some(keyWord => message === keyWord));\n};\n\nexports.tagDirective = tagDirective;","map":{"version":3,"sources":["../../../../src/composition/validate/preNormalization/tagDirective.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,YAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAOA,MAAA,wBAAA,GAAA,OAAA,CAAA,iDAAA,CAAA;;AACA,MAAA,+BAAA,GAAA,OAAA,CAAA,wDAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,6BAAA,CAAA;;AAEA,MAAA,OAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAKA,MAAM,sBAAsB,GAAG,YAAA,CAAA,oBAAA,CAAqB,GAArB,CAC5B,SAAD,IAAe,uBAAuB,SAAS,CAAC,IAAI,IADvB,CAA/B;;AAOO,MAAM,YAAY,GAAG,CAAC;AAC3B,EAAA,IAAI,EAAE,WADqB;AAE3B,EAAA;AAF2B,CAAD,KAGJ;AAGtB,QAAM,cAAc,GAAG,CACrB,wBAAA,CAAA,kCADqB,EAErB,SAAA,CAAA,mBAFqB,EAGrB,+BAAA,CAAA,yCAHqB,CAAvB;AAMA,QAAM,MAAM,GAAG,UAAA,CAAA,WAAA,CAAY,QAAZ,EAAsB,SAAtB,EAAiC,cAAjC,CAAf;AAEA,MAAI,sBAAJ;AACA,EAAA,SAAA,CAAA,KAAA,CAAM,QAAN,EAAgB;AACd,IAAA,mBAAmB,CAAC,IAAD,EAAK;AACtB,UAAI,IAAI,CAAC,IAAL,CAAU,KAAV,KAAoB,KAAxB,EAA+B;AAC7B,QAAA,sBAAsB,GAAG,IAAzB;AACA,eAAO,SAAA,CAAA,KAAP;AACD;AACF;;AANa,GAAhB;;AAUA,MAAI,sBAAJ,EAA4B;AAC1B,UAAM,oBAAoB,GACxB,8DADF;;AAGA,QACE,SAAA,CAAA,KAAA,CAAM,OAAA,CAAA,iBAAA,CAAkB,sBAAlB,CAAN,MAAqD,oBADvD,EAEE;AACA,MAAA,MAAM,CAAC,IAAP,CACE,OAAA,CAAA,aAAA,CACE,kCADF,EAEE,OAAA,CAAA,YAAA,CAAa,KAAb,IACE,oCAAoC,WAAW,uJAAuJ,oBAAoB,EAH9N,EAIE,sBAJF,CADF;AAQD;AACF;;AAED,SAAO,MAAM,CAAC,MAAP,CACL,CAAC;AAAE,IAAA;AAAF,GAAD,KACE,CAAC,sBAAsB,CAAC,IAAvB,CAA6B,OAAD,IAAa,OAAO,KAAK,OAArD,CAFE,CAAP;AAID,CA/CM;;AAAM,OAAA,CAAA,YAAA,GAAY,YAAZ","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.tagDirective = void 0;\nconst directives_1 = require(\"../../../directives\");\nconst graphql_1 = require(\"graphql\");\nconst KnownArgumentNamesRule_1 = require(\"graphql/validation/rules/KnownArgumentNamesRule\");\nconst ProvidedRequiredArgumentsRule_1 = require(\"graphql/validation/rules/ProvidedRequiredArgumentsRule\");\nconst validate_1 = require(\"graphql/validation/validate\");\nconst utils_1 = require(\"../../utils\");\nconst errorsMessagesToFilter = directives_1.federationDirectives.map((directive) => `Unknown directive \"@${directive.name}\".`);\nconst tagDirective = ({ name: serviceName, typeDefs, }) => {\n    const directiveRules = [\n        KnownArgumentNamesRule_1.KnownArgumentNamesOnDirectivesRule,\n        graphql_1.KnownDirectivesRule,\n        ProvidedRequiredArgumentsRule_1.ProvidedRequiredArgumentsOnDirectivesRule,\n    ];\n    const errors = validate_1.validateSDL(typeDefs, undefined, directiveRules);\n    let tagDirectiveDefinition;\n    graphql_1.visit(typeDefs, {\n        DirectiveDefinition(node) {\n            if (node.name.value === 'tag') {\n                tagDirectiveDefinition = node;\n                return graphql_1.BREAK;\n            }\n        },\n    });\n    if (tagDirectiveDefinition) {\n        const printedTagDefinition = 'directive @tag(name: String!) repeatable on FIELD_DEFINITION';\n        if (graphql_1.print(utils_1.stripDescriptions(tagDirectiveDefinition)) !== printedTagDefinition) {\n            errors.push(utils_1.errorWithCode('TAG_DIRECTIVE_DEFINITION_INVALID', utils_1.logDirective('tag') +\n                `Found @tag definition in service ${serviceName}, but the @tag directive definition was invalid. Please ensure the directive definition in your schema's type definitions matches the following:\\n\\t${printedTagDefinition}`, tagDirectiveDefinition));\n        }\n    }\n    return errors.filter(({ message }) => !errorsMessagesToFilter.some((keyWord) => message === keyWord));\n};\nexports.tagDirective = tagDirective;\n//# sourceMappingURL=tagDirective.js.map"]},"metadata":{},"sourceType":"script"}