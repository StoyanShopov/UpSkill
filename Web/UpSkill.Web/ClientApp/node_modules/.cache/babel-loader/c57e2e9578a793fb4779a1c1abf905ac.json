{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getASTNodeAndTypeInfoAtPosition = exports.positionToOffset = exports.positionFromSourceLocation = exports.rangeForASTNode = exports.rangeInContainingDocument = exports.positionInContainingDocument = exports.positionFromPositionInContainingDocument = exports.visitWithTypeInfo = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst location_1 = require(\"graphql/language/location\");\n\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\n\nconst graphql_2 = require(\"./graphql\");\n\nfunction visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter(node) {\n      typeInfo.enter(node);\n      const fn = graphql_1.getVisitFn(visitor, node.kind, false);\n\n      if (fn) {\n        const result = fn.apply(visitor, arguments);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (graphql_2.isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n\n    leave(node) {\n      const fn = graphql_1.getVisitFn(visitor, node.kind, true);\n      let result;\n\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n\n      if (result !== graphql_1.BREAK) {\n        typeInfo.leave(node);\n      }\n\n      return result;\n    }\n\n  };\n}\n\nexports.visitWithTypeInfo = visitWithTypeInfo;\n\nfunction positionFromPositionInContainingDocument(source, position) {\n  if (!source.locationOffset) return position;\n  return vscode_languageserver_1.Position.create(position.line - (source.locationOffset.line - 1), position.character);\n}\n\nexports.positionFromPositionInContainingDocument = positionFromPositionInContainingDocument;\n\nfunction positionInContainingDocument(source, position) {\n  if (!source.locationOffset) return position;\n  return vscode_languageserver_1.Position.create(source.locationOffset.line - 1 + position.line, position.character);\n}\n\nexports.positionInContainingDocument = positionInContainingDocument;\n\nfunction rangeInContainingDocument(source, range) {\n  if (!source.locationOffset) return range;\n  return vscode_languageserver_1.Range.create(positionInContainingDocument(source, range.start), positionInContainingDocument(source, range.end));\n}\n\nexports.rangeInContainingDocument = rangeInContainingDocument;\n\nfunction rangeForASTNode(node) {\n  const location = node.loc;\n  const source = location.source;\n  return vscode_languageserver_1.Range.create(positionFromSourceLocation(source, location_1.getLocation(source, location.start)), positionFromSourceLocation(source, location_1.getLocation(source, location.end)));\n}\n\nexports.rangeForASTNode = rangeForASTNode;\n\nfunction positionFromSourceLocation(source, location) {\n  return vscode_languageserver_1.Position.create((source.locationOffset ? source.locationOffset.line - 1 : 0) + location.line - 1, (source.locationOffset && location.line === 1 ? source.locationOffset.column - 1 : 0) + location.column - 1);\n}\n\nexports.positionFromSourceLocation = positionFromSourceLocation;\n\nfunction positionToOffset(source, position) {\n  const lineRegexp = /\\r\\n|[\\n\\r]/g;\n  const lineEndingLength = /\\r\\n/g.test(source.body) ? 2 : 1;\n  const linesUntilPosition = source.body.split(lineRegexp).slice(0, position.line);\n  return position.character + linesUntilPosition.map(line => line.length + lineEndingLength).reduce((a, b) => a + b, 0);\n}\n\nexports.positionToOffset = positionToOffset;\n\nfunction getASTNodeAndTypeInfoAtPosition(source, position, root, schema) {\n  const offset = positionToOffset(source, position);\n  let nodeContainingPosition = null;\n  const typeInfo = new graphql_1.TypeInfo(schema);\n  graphql_1.visit(root, visitWithTypeInfo(typeInfo, {\n    enter(node) {\n      if (node.kind !== graphql_1.Kind.NAME && node.loc && node.loc.start <= offset && offset <= node.loc.end) {\n        nodeContainingPosition = node;\n      } else {\n        return false;\n      }\n\n      return;\n    },\n\n    leave(node) {\n      if (node.loc && node.loc.start <= offset && offset <= node.loc.end) {\n        return graphql_1.BREAK;\n      }\n\n      return;\n    }\n\n  }));\n\n  if (nodeContainingPosition) {\n    return [nodeContainingPosition, typeInfo];\n  } else {\n    return null;\n  }\n}\n\nexports.getASTNodeAndTypeInfoAtPosition = getASTNodeAndTypeInfoAtPosition;","map":{"version":3,"sources":["../../src/utilities/source.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAeA,MAAA,UAAA,GAAA,OAAA,CAAA,2BAAA,CAAA;;AAEA,MAAA,uBAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AAEA,MAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AAeA,SAAgB,iBAAhB,CACE,QADF,EAEE,OAFF,EAEiC;AAE/B,SAAO;AACL,IAAA,KAAK,CAAC,IAAD,EAAc;AACjB,MAAA,QAAQ,CAAC,KAAT,CAAe,IAAf;AACA,YAAM,EAAE,GAAG,SAAA,CAAA,UAAA,CAAW,OAAX,EAAoB,IAAI,CAAC,IAAzB,EAA+C,KAA/C,CAAX;;AACA,UAAI,EAAJ,EAAQ;AACN,cAAM,MAAM,GAAG,EAAE,CAAC,KAAH,CAAS,OAAT,EAAmB,SAAnB,CAAf;;AACA,YAAI,MAAM,KAAK,SAAf,EAA0B;AACxB,UAAA,QAAQ,CAAC,KAAT,CAAe,IAAf;;AACA,cAAI,SAAA,CAAA,MAAA,CAAO,MAAP,CAAJ,EAAoB;AAClB,YAAA,QAAQ,CAAC,KAAT,CAAe,MAAf;AACD;AACF;;AACD,eAAO,MAAP;AACD;AACF,KAdI;;AAeL,IAAA,KAAK,CAAC,IAAD,EAAc;AACjB,YAAM,EAAE,GAAG,SAAA,CAAA,UAAA,CAAW,OAAX,EAAoB,IAAI,CAAC,IAAzB,EAA+C,IAA/C,CAAX;AACA,UAAI,MAAJ;;AACA,UAAI,EAAJ,EAAQ;AACN,QAAA,MAAM,GAAG,EAAE,CAAC,KAAH,CAAS,OAAT,EAAmB,SAAnB,CAAT;AACD;;AAID,UAAI,MAAM,KAAK,SAAA,CAAA,KAAf,EAAsB;AACpB,QAAA,QAAQ,CAAC,KAAT,CAAe,IAAf;AACD;;AACD,aAAO,MAAP;AACD;;AA5BI,GAAP;AA8BD;;AAlCD,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AAoCA,SAAgB,wCAAhB,CACE,MADF,EAEE,QAFF,EAEoB;AAElB,MAAI,CAAC,MAAM,CAAC,cAAZ,EAA4B,OAAO,QAAP;AAC5B,SAAO,uBAAA,CAAA,QAAA,CAAS,MAAT,CACL,QAAQ,CAAC,IAAT,IAAiB,MAAM,CAAC,cAAP,CAAsB,IAAtB,GAA6B,CAA9C,CADK,EAEL,QAAQ,CAAC,SAFJ,CAAP;AAID;;AATD,OAAA,CAAA,wCAAA,GAAA,wCAAA;;AAWA,SAAgB,4BAAhB,CACE,MADF,EAEE,QAFF,EAEoB;AAElB,MAAI,CAAC,MAAM,CAAC,cAAZ,EAA4B,OAAO,QAAP;AAC5B,SAAO,uBAAA,CAAA,QAAA,CAAS,MAAT,CACL,MAAM,CAAC,cAAP,CAAsB,IAAtB,GAA6B,CAA7B,GAAiC,QAAQ,CAAC,IADrC,EAEL,QAAQ,CAAC,SAFJ,CAAP;AAID;;AATD,OAAA,CAAA,4BAAA,GAAA,4BAAA;;AAWA,SAAgB,yBAAhB,CAA0C,MAA1C,EAA0D,KAA1D,EAAsE;AACpE,MAAI,CAAC,MAAM,CAAC,cAAZ,EAA4B,OAAO,KAAP;AAC5B,SAAO,uBAAA,CAAA,KAAA,CAAM,MAAN,CACL,4BAA4B,CAAC,MAAD,EAAS,KAAK,CAAC,KAAf,CADvB,EAEL,4BAA4B,CAAC,MAAD,EAAS,KAAK,CAAC,GAAf,CAFvB,CAAP;AAID;;AAND,OAAA,CAAA,yBAAA,GAAA,yBAAA;;AAQA,SAAgB,eAAhB,CAAgC,IAAhC,EAA6C;AAC3C,QAAM,QAAQ,GAAG,IAAI,CAAC,GAAtB;AACA,QAAM,MAAM,GAAG,QAAQ,CAAC,MAAxB;AAEA,SAAO,uBAAA,CAAA,KAAA,CAAM,MAAN,CACL,0BAA0B,CAAC,MAAD,EAAS,UAAA,CAAA,WAAA,CAAY,MAAZ,EAAoB,QAAQ,CAAC,KAA7B,CAAT,CADrB,EAEL,0BAA0B,CAAC,MAAD,EAAS,UAAA,CAAA,WAAA,CAAY,MAAZ,EAAoB,QAAQ,CAAC,GAA7B,CAAT,CAFrB,CAAP;AAID;;AARD,OAAA,CAAA,eAAA,GAAA,eAAA;;AAUA,SAAgB,0BAAhB,CACE,MADF,EAEE,QAFF,EAE0B;AAExB,SAAO,uBAAA,CAAA,QAAA,CAAS,MAAT,CACL,CAAC,MAAM,CAAC,cAAP,GAAwB,MAAM,CAAC,cAAP,CAAsB,IAAtB,GAA6B,CAArD,GAAyD,CAA1D,IACE,QAAQ,CAAC,IADX,GAEE,CAHG,EAIL,CAAC,MAAM,CAAC,cAAP,IAAyB,QAAQ,CAAC,IAAT,KAAkB,CAA3C,GACG,MAAM,CAAC,cAAP,CAAsB,MAAtB,GAA+B,CADlC,GAEG,CAFJ,IAGE,QAAQ,CAAC,MAHX,GAIE,CARG,CAAP;AAUD;;AAdD,OAAA,CAAA,0BAAA,GAAA,0BAAA;;AAgBA,SAAgB,gBAAhB,CAAiC,MAAjC,EAAiD,QAAjD,EAAmE;AACjE,QAAM,UAAU,GAAG,cAAnB;AACA,QAAM,gBAAgB,GAAG,QAAQ,IAAR,CAAa,MAAM,CAAC,IAApB,IAA4B,CAA5B,GAAgC,CAAzD;AAEA,QAAM,kBAAkB,GAAG,MAAM,CAAC,IAAP,CACxB,KADwB,CAClB,UADkB,EAExB,KAFwB,CAElB,CAFkB,EAEf,QAAQ,CAAC,IAFM,CAA3B;AAGA,SACE,QAAQ,CAAC,SAAT,GACA,kBAAkB,CACf,GADH,CAEI,IAAI,IAAI,IAAI,CAAC,MAAL,GAAc,gBAF1B,EAIG,MAJH,CAIU,CAAC,CAAD,EAAI,CAAJ,KAAU,CAAC,GAAG,CAJxB,EAI2B,CAJ3B,CAFF;AAQD;;AAfD,OAAA,CAAA,gBAAA,GAAA,gBAAA;;AAiBA,SAAgB,+BAAhB,CACE,MADF,EAEE,QAFF,EAGE,IAHF,EAIE,MAJF,EAIuB;AAErB,QAAM,MAAM,GAAG,gBAAgB,CAAC,MAAD,EAAS,QAAT,CAA/B;AAEA,MAAI,sBAAsB,GAAmB,IAA7C;AAEA,QAAM,QAAQ,GAAG,IAAI,SAAA,CAAA,QAAJ,CAAa,MAAb,CAAjB;AACA,EAAA,SAAA,CAAA,KAAA,CACE,IADF,EAEE,iBAAiB,CAAC,QAAD,EAAW;AAC1B,IAAA,KAAK,CAAC,IAAD,EAAc;AACjB,UACE,IAAI,CAAC,IAAL,KAAc,SAAA,CAAA,IAAA,CAAK,IAAnB,IACA,IAAI,CAAC,GADL,IAEA,IAAI,CAAC,GAAL,CAAS,KAAT,IAAkB,MAFlB,IAGA,MAAM,IAAI,IAAI,CAAC,GAAL,CAAS,GAJrB,EAKE;AACA,QAAA,sBAAsB,GAAG,IAAzB;AACD,OAPD,MAOO;AACL,eAAO,KAAP;AACD;;AACD;AACD,KAbyB;;AAc1B,IAAA,KAAK,CAAC,IAAD,EAAc;AACjB,UAAI,IAAI,CAAC,GAAL,IAAY,IAAI,CAAC,GAAL,CAAS,KAAT,IAAkB,MAA9B,IAAwC,MAAM,IAAI,IAAI,CAAC,GAAL,CAAS,GAA/D,EAAoE;AAClE,eAAO,SAAA,CAAA,KAAP;AACD;;AACD;AACD;;AAnByB,GAAX,CAFnB;;AAyBA,MAAI,sBAAJ,EAA4B;AAC1B,WAAO,CAAC,sBAAD,EAAyB,QAAzB,CAAP;AACD,GAFD,MAEO;AACL,WAAO,IAAP;AACD;AACF;;AAzCD,OAAA,CAAA,+BAAA,GAAA,+BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getASTNodeAndTypeInfoAtPosition = exports.positionToOffset = exports.positionFromSourceLocation = exports.rangeForASTNode = exports.rangeInContainingDocument = exports.positionInContainingDocument = exports.positionFromPositionInContainingDocument = exports.visitWithTypeInfo = void 0;\nconst graphql_1 = require(\"graphql\");\nconst location_1 = require(\"graphql/language/location\");\nconst vscode_languageserver_1 = require(\"vscode-languageserver\");\nconst graphql_2 = require(\"./graphql\");\nfunction visitWithTypeInfo(typeInfo, visitor) {\n    return {\n        enter(node) {\n            typeInfo.enter(node);\n            const fn = graphql_1.getVisitFn(visitor, node.kind, false);\n            if (fn) {\n                const result = fn.apply(visitor, arguments);\n                if (result !== undefined) {\n                    typeInfo.leave(node);\n                    if (graphql_2.isNode(result)) {\n                        typeInfo.enter(result);\n                    }\n                }\n                return result;\n            }\n        },\n        leave(node) {\n            const fn = graphql_1.getVisitFn(visitor, node.kind, true);\n            let result;\n            if (fn) {\n                result = fn.apply(visitor, arguments);\n            }\n            if (result !== graphql_1.BREAK) {\n                typeInfo.leave(node);\n            }\n            return result;\n        }\n    };\n}\nexports.visitWithTypeInfo = visitWithTypeInfo;\nfunction positionFromPositionInContainingDocument(source, position) {\n    if (!source.locationOffset)\n        return position;\n    return vscode_languageserver_1.Position.create(position.line - (source.locationOffset.line - 1), position.character);\n}\nexports.positionFromPositionInContainingDocument = positionFromPositionInContainingDocument;\nfunction positionInContainingDocument(source, position) {\n    if (!source.locationOffset)\n        return position;\n    return vscode_languageserver_1.Position.create(source.locationOffset.line - 1 + position.line, position.character);\n}\nexports.positionInContainingDocument = positionInContainingDocument;\nfunction rangeInContainingDocument(source, range) {\n    if (!source.locationOffset)\n        return range;\n    return vscode_languageserver_1.Range.create(positionInContainingDocument(source, range.start), positionInContainingDocument(source, range.end));\n}\nexports.rangeInContainingDocument = rangeInContainingDocument;\nfunction rangeForASTNode(node) {\n    const location = node.loc;\n    const source = location.source;\n    return vscode_languageserver_1.Range.create(positionFromSourceLocation(source, location_1.getLocation(source, location.start)), positionFromSourceLocation(source, location_1.getLocation(source, location.end)));\n}\nexports.rangeForASTNode = rangeForASTNode;\nfunction positionFromSourceLocation(source, location) {\n    return vscode_languageserver_1.Position.create((source.locationOffset ? source.locationOffset.line - 1 : 0) +\n        location.line -\n        1, (source.locationOffset && location.line === 1\n        ? source.locationOffset.column - 1\n        : 0) +\n        location.column -\n        1);\n}\nexports.positionFromSourceLocation = positionFromSourceLocation;\nfunction positionToOffset(source, position) {\n    const lineRegexp = /\\r\\n|[\\n\\r]/g;\n    const lineEndingLength = /\\r\\n/g.test(source.body) ? 2 : 1;\n    const linesUntilPosition = source.body\n        .split(lineRegexp)\n        .slice(0, position.line);\n    return (position.character +\n        linesUntilPosition\n            .map(line => line.length + lineEndingLength)\n            .reduce((a, b) => a + b, 0));\n}\nexports.positionToOffset = positionToOffset;\nfunction getASTNodeAndTypeInfoAtPosition(source, position, root, schema) {\n    const offset = positionToOffset(source, position);\n    let nodeContainingPosition = null;\n    const typeInfo = new graphql_1.TypeInfo(schema);\n    graphql_1.visit(root, visitWithTypeInfo(typeInfo, {\n        enter(node) {\n            if (node.kind !== graphql_1.Kind.NAME &&\n                node.loc &&\n                node.loc.start <= offset &&\n                offset <= node.loc.end) {\n                nodeContainingPosition = node;\n            }\n            else {\n                return false;\n            }\n            return;\n        },\n        leave(node) {\n            if (node.loc && node.loc.start <= offset && offset <= node.loc.end) {\n                return graphql_1.BREAK;\n            }\n            return;\n        }\n    }));\n    if (nodeContainingPosition) {\n        return [nodeContainingPosition, typeInfo];\n    }\n    else {\n        return null;\n    }\n}\nexports.getASTNodeAndTypeInfoAtPosition = getASTNodeAndTypeInfoAtPosition;\n//# sourceMappingURL=source.js.map"]},"metadata":{},"sourceType":"script"}