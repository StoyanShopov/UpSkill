{"ast":null,"code":"import inspect from '../../jsutils/inspect';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { isCompositeType } from '../../type/definition';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nimport { doTypesOverlap } from '../../utilities/typeComparators';\nexport function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\n  return \"Fragment \\\"\".concat(fragName, \"\\\" cannot be spread here as objects of type \\\"\").concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\nexport function typeIncompatibleAnonSpreadMessage(parentType, fragType) {\n  return \"Fragment cannot be spread here as objects of type \\\"\".concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\n\nexport function PossibleFragmentSpreads(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleAnonSpreadMessage(inspect(parentType), inspect(fragType)), node));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleSpreadMessage(fragName, inspect(parentType), inspect(fragType)), node));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n\n  if (frag) {\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}","map":{"version":3,"sources":["H:/Programming Repositories/Titans/Web/UpSkill.Web/ClientApp/node_modules/graphql/validation/rules/PossibleFragmentSpreads.mjs"],"names":["inspect","GraphQLError","isCompositeType","typeFromAST","doTypesOverlap","typeIncompatibleSpreadMessage","fragName","parentType","fragType","concat","typeIncompatibleAnonSpreadMessage","PossibleFragmentSpreads","context","InlineFragment","node","getType","getParentType","getSchema","reportError","FragmentSpread","name","value","getFragmentType","frag","getFragment","type","typeCondition"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,uBAApB;AACA,SAASC,YAAT,QAA6B,0BAA7B;AACA,SAASC,eAAT,QAAgC,uBAAhC;AACA,SAASC,WAAT,QAA4B,6BAA5B;AACA,SAASC,cAAT,QAA+B,iCAA/B;AACA,OAAO,SAASC,6BAAT,CAAuCC,QAAvC,EAAiDC,UAAjD,EAA6DC,QAA7D,EAAuE;AAC5E,SAAO,cAAcC,MAAd,CAAqBH,QAArB,EAA+B,gDAA/B,EAAiFG,MAAjF,CAAwFF,UAAxF,EAAoG,4BAApG,EAAkIE,MAAlI,CAAyID,QAAzI,EAAmJ,KAAnJ,CAAP;AACD;AACD,OAAO,SAASE,iCAAT,CAA2CH,UAA3C,EAAuDC,QAAvD,EAAiE;AACtE,SAAO,uDAAuDC,MAAvD,CAA8DF,UAA9D,EAA0E,4BAA1E,EAAwGE,MAAxG,CAA+GD,QAA/G,EAAyH,KAAzH,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASG,uBAAT,CAAiCC,OAAjC,EAA0C;AAC/C,SAAO;AACLC,IAAAA,cAAc,EAAE,SAASA,cAAT,CAAwBC,IAAxB,EAA8B;AAC5C,UAAIN,QAAQ,GAAGI,OAAO,CAACG,OAAR,EAAf;AACA,UAAIR,UAAU,GAAGK,OAAO,CAACI,aAAR,EAAjB;;AAEA,UAAId,eAAe,CAACM,QAAD,CAAf,IAA6BN,eAAe,CAACK,UAAD,CAA5C,IAA4D,CAACH,cAAc,CAACQ,OAAO,CAACK,SAAR,EAAD,EAAsBT,QAAtB,EAAgCD,UAAhC,CAA/E,EAA4H;AAC1HK,QAAAA,OAAO,CAACM,WAAR,CAAoB,IAAIjB,YAAJ,CAAiBS,iCAAiC,CAACV,OAAO,CAACO,UAAD,CAAR,EAAsBP,OAAO,CAACQ,QAAD,CAA7B,CAAlD,EAA4FM,IAA5F,CAApB;AACD;AACF,KARI;AASLK,IAAAA,cAAc,EAAE,SAASA,cAAT,CAAwBL,IAAxB,EAA8B;AAC5C,UAAIR,QAAQ,GAAGQ,IAAI,CAACM,IAAL,CAAUC,KAAzB;AACA,UAAIb,QAAQ,GAAGc,eAAe,CAACV,OAAD,EAAUN,QAAV,CAA9B;AACA,UAAIC,UAAU,GAAGK,OAAO,CAACI,aAAR,EAAjB;;AAEA,UAAIR,QAAQ,IAAID,UAAZ,IAA0B,CAACH,cAAc,CAACQ,OAAO,CAACK,SAAR,EAAD,EAAsBT,QAAtB,EAAgCD,UAAhC,CAA7C,EAA0F;AACxFK,QAAAA,OAAO,CAACM,WAAR,CAAoB,IAAIjB,YAAJ,CAAiBI,6BAA6B,CAACC,QAAD,EAAWN,OAAO,CAACO,UAAD,CAAlB,EAAgCP,OAAO,CAACQ,QAAD,CAAvC,CAA9C,EAAkGM,IAAlG,CAApB;AACD;AACF;AAjBI,GAAP;AAmBD;;AAED,SAASQ,eAAT,CAAyBV,OAAzB,EAAkCQ,IAAlC,EAAwC;AACtC,MAAIG,IAAI,GAAGX,OAAO,CAACY,WAAR,CAAoBJ,IAApB,CAAX;;AAEA,MAAIG,IAAJ,EAAU;AACR,QAAIE,IAAI,GAAGtB,WAAW,CAACS,OAAO,CAACK,SAAR,EAAD,EAAsBM,IAAI,CAACG,aAA3B,CAAtB;;AAEA,QAAIxB,eAAe,CAACuB,IAAD,CAAnB,EAA2B;AACzB,aAAOA,IAAP;AACD;AACF;AACF","sourcesContent":["import inspect from '../../jsutils/inspect';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { isCompositeType } from '../../type/definition';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nimport { doTypesOverlap } from '../../utilities/typeComparators';\nexport function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\n  return \"Fragment \\\"\".concat(fragName, \"\\\" cannot be spread here as objects of type \\\"\").concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\nexport function typeIncompatibleAnonSpreadMessage(parentType, fragType) {\n  return \"Fragment cannot be spread here as objects of type \\\"\".concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\n\nexport function PossibleFragmentSpreads(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleAnonSpreadMessage(inspect(parentType), inspect(fragType)), node));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(typeIncompatibleSpreadMessage(fragName, inspect(parentType), inspect(fragType)), node));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n\n  if (frag) {\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}