{"ast":null,"code":"// code is originally from https://github.com/AnAppAMonth/linewrap\n// Presets\nvar presetMap = {\n  'html': {\n    skipScheme: 'html',\n    lineBreakScheme: 'html',\n    whitespace: 'collapse'\n  }\n}; // lineBreak Schemes\n\nvar brPat = /<\\s*br(?:[\\s/]*|\\s[^>]*)>/gi;\nvar lineBreakSchemeMap = {\n  'unix': [/\\n/g, '\\n'],\n  'dos': [/\\r\\n/g, '\\r\\n'],\n  'mac': [/\\r/g, '\\r'],\n  'html': [brPat, '<br>'],\n  'xhtml': [brPat, '<br/>']\n}; // skip Schemes\n\nvar skipSchemeMap = {\n  'ansi-color': /\\x1B\\[[^m]*m/g,\n  'html': /<[^>]*>/g,\n  'bbcode': /\\[[^]]*\\]/g\n};\nvar modeMap = {\n  'soft': 1,\n  'hard': 1\n};\nvar wsMap = {\n  'collapse': 1,\n  'default': 1,\n  'line': 1,\n  'all': 1\n};\nvar rlbMap = {\n  'all': 1,\n  'multi': 1,\n  'none': 1\n};\nvar rlbSMPat = /([sm])(\\d+)/;\nvar escapePat = /[-/\\\\^$*+?.()|[\\]{}]/g;\n\nfunction escapeRegExp(s) {\n  return s.replace(escapePat, '\\\\$&');\n}\n\nvar linewrap = module.exports = function (start, stop, params) {\n  if (typeof start === 'object') {\n    params = start;\n    start = params.start;\n    stop = params.stop;\n  }\n\n  if (typeof stop === 'object') {\n    params = stop;\n    start = start || params.start;\n    stop = undefined;\n  }\n\n  if (!stop) {\n    stop = start;\n    start = 0;\n  }\n\n  if (!params) {\n    params = {};\n  } // Supported options and default values.\n\n\n  var preset,\n      mode = 'soft',\n      whitespace = 'default',\n      tabWidth = 4,\n      skip,\n      skipScheme,\n      lineBreak,\n      lineBreakScheme,\n      respectLineBreaks = 'all',\n      respectNum,\n      preservedLineIndent,\n      wrapLineIndent,\n      wrapLineIndentBase;\n  var skipPat;\n  var lineBreakPat, lineBreakStr;\n  var multiLineBreakPat;\n  var preservedLinePrefix = '';\n  var wrapLineIndentPat,\n      wrapLineInitPrefix = '';\n  var tabRepl;\n  var item, flags;\n  var i; // First process presets, because these settings can be overwritten later.\n\n  preset = params.preset;\n\n  if (preset) {\n    if (!(preset instanceof Array)) {\n      preset = [preset];\n    }\n\n    for (i = 0; i < preset.length; i++) {\n      item = presetMap[preset[i]];\n\n      if (item) {\n        if (item.mode) {\n          mode = item.mode;\n        }\n\n        if (item.whitespace) {\n          whitespace = item.whitespace;\n        }\n\n        if (item.tabWidth !== undefined) {\n          tabWidth = item.tabWidth;\n        }\n\n        if (item.skip) {\n          skip = item.skip;\n        }\n\n        if (item.skipScheme) {\n          skipScheme = item.skipScheme;\n        }\n\n        if (item.lineBreak) {\n          lineBreak = item.lineBreak;\n        }\n\n        if (item.lineBreakScheme) {\n          lineBreakScheme = item.lineBreakScheme;\n        }\n\n        if (item.respectLineBreaks) {\n          respectLineBreaks = item.respectLineBreaks;\n        }\n\n        if (item.preservedLineIndent !== undefined) {\n          preservedLineIndent = item.preservedLineIndent;\n        }\n\n        if (item.wrapLineIndent !== undefined) {\n          wrapLineIndent = item.wrapLineIndent;\n        }\n\n        if (item.wrapLineIndentBase) {\n          wrapLineIndentBase = item.wrapLineIndentBase;\n        }\n      } else {\n        throw new TypeError('preset must be one of \"' + Object.keys(presetMap).join('\", \"') + '\"');\n      }\n    }\n  }\n\n  if (params.mode) {\n    if (modeMap[params.mode]) {\n      mode = params.mode;\n    } else {\n      throw new TypeError('mode must be one of \"' + Object.keys(modeMap).join('\", \"') + '\"');\n    }\n  } // Available options: 'collapse', 'default', 'line', and 'all'\n\n\n  if (params.whitespace) {\n    if (wsMap[params.whitespace]) {\n      whitespace = params.whitespace;\n    } else {\n      throw new TypeError('whitespace must be one of \"' + Object.keys(wsMap).join('\", \"') + '\"');\n    }\n  }\n\n  if (params.tabWidth !== undefined) {\n    if (parseInt(params.tabWidth, 10) >= 0) {\n      tabWidth = parseInt(params.tabWidth, 10);\n    } else {\n      throw new TypeError('tabWidth must be a non-negative integer');\n    }\n  }\n\n  tabRepl = new Array(tabWidth + 1).join(' '); // Available options: 'all', 'multi', 'm\\d+', 's\\d+', 'none'\n\n  if (params.respectLineBreaks) {\n    if (rlbMap[params.respectLineBreaks] || rlbSMPat.test(params.respectLineBreaks)) {\n      respectLineBreaks = params.respectLineBreaks;\n    } else {\n      throw new TypeError('respectLineBreaks must be one of \"' + Object.keys(rlbMap).join('\", \"') + '\", \"m<num>\", \"s<num>\"');\n    }\n  } // After these conversions, now we have 4 options in `respectLineBreaks`:\n  // 'all', 'none', 'm' and 's'.\n  // `respectNum` is applicable iff `respectLineBreaks` is either 'm' or 's'.\n\n\n  if (respectLineBreaks === 'multi') {\n    respectLineBreaks = 'm';\n    respectNum = 2;\n  } else if (!rlbMap[respectLineBreaks]) {\n    var match = rlbSMPat.exec(respectLineBreaks);\n    respectLineBreaks = match[1];\n    respectNum = parseInt(match[2], 10);\n  }\n\n  if (params.preservedLineIndent !== undefined) {\n    if (parseInt(params.preservedLineIndent, 10) >= 0) {\n      preservedLineIndent = parseInt(params.preservedLineIndent, 10);\n    } else {\n      throw new TypeError('preservedLineIndent must be a non-negative integer');\n    }\n  }\n\n  if (preservedLineIndent > 0) {\n    preservedLinePrefix = new Array(preservedLineIndent + 1).join(' ');\n  }\n\n  if (params.wrapLineIndent !== undefined) {\n    if (!isNaN(parseInt(params.wrapLineIndent, 10))) {\n      wrapLineIndent = parseInt(params.wrapLineIndent, 10);\n    } else {\n      throw new TypeError('wrapLineIndent must be an integer');\n    }\n  }\n\n  if (params.wrapLineIndentBase) {\n    wrapLineIndentBase = params.wrapLineIndentBase;\n  }\n\n  if (wrapLineIndentBase) {\n    if (wrapLineIndent === undefined) {\n      throw new TypeError('wrapLineIndent must be specified when wrapLineIndentBase is specified');\n    }\n\n    if (wrapLineIndentBase instanceof RegExp) {\n      wrapLineIndentPat = wrapLineIndentBase;\n    } else if (typeof wrapLineIndentBase === 'string') {\n      wrapLineIndentPat = new RegExp(escapeRegExp(wrapLineIndentBase));\n    } else {\n      throw new TypeError('wrapLineIndentBase must be either a RegExp object or a string');\n    }\n  } else if (wrapLineIndent > 0) {\n    wrapLineInitPrefix = new Array(wrapLineIndent + 1).join(' ');\n  } else if (wrapLineIndent < 0) {\n    throw new TypeError('wrapLineIndent must be non-negative when a base is not specified');\n  } // NOTE: For the two RegExps `skipPat` and `lineBreakPat` that can be specified\n  //       by the user:\n  //       1. We require them to be \"global\", so we have to convert them to global\n  //          if the user specifies a non-global regex.\n  //       2. We cannot call `split()` on them, because they may or may not contain\n  //          capturing parentheses which affect the output of `split()`.\n  // Precedence: Regex = Str > Scheme\n\n\n  if (params.skipScheme) {\n    if (skipSchemeMap[params.skipScheme]) {\n      skipScheme = params.skipScheme;\n    } else {\n      throw new TypeError('skipScheme must be one of \"' + Object.keys(skipSchemeMap).join('\", \"') + '\"');\n    }\n  }\n\n  if (params.skip) {\n    skip = params.skip;\n  }\n\n  if (skip) {\n    if (skip instanceof RegExp) {\n      skipPat = skip;\n\n      if (!skipPat.global) {\n        flags = 'g';\n\n        if (skipPat.ignoreCase) {\n          flags += 'i';\n        }\n\n        if (skipPat.multiline) {\n          flags += 'm';\n        }\n\n        skipPat = new RegExp(skipPat.source, flags);\n      }\n    } else if (typeof skip === 'string') {\n      skipPat = new RegExp(escapeRegExp(skip), 'g');\n    } else {\n      throw new TypeError('skip must be either a RegExp object or a string');\n    }\n  }\n\n  if (!skipPat && skipScheme) {\n    skipPat = skipSchemeMap[skipScheme];\n  } // Precedence:\n  // - for lineBreakPat: Regex > Scheme > Str\n  // - for lineBreakStr: Str > Scheme > Regex\n\n\n  if (params.lineBreakScheme) {\n    if (lineBreakSchemeMap[params.lineBreakScheme]) {\n      lineBreakScheme = params.lineBreakScheme;\n    } else {\n      throw new TypeError('lineBreakScheme must be one of \"' + Object.keys(lineBreakSchemeMap).join('\", \"') + '\"');\n    }\n  }\n\n  if (params.lineBreak) {\n    lineBreak = params.lineBreak;\n  }\n\n  if (lineBreakScheme) {\n    // Supported schemes: 'unix', 'dos', 'mac', 'html', 'xhtml'\n    item = lineBreakSchemeMap[lineBreakScheme];\n\n    if (item) {\n      lineBreakPat = item[0];\n      lineBreakStr = item[1];\n    }\n  }\n\n  if (lineBreak) {\n    if (lineBreak instanceof Array) {\n      if (lineBreak.length === 1) {\n        lineBreak = lineBreak[0];\n      } else if (lineBreak.length >= 2) {\n        if (lineBreak[0] instanceof RegExp) {\n          lineBreakPat = lineBreak[0];\n\n          if (typeof lineBreak[1] === 'string') {\n            lineBreakStr = lineBreak[1];\n          }\n        } else if (lineBreak[1] instanceof RegExp) {\n          lineBreakPat = lineBreak[1];\n\n          if (typeof lineBreak[0] === 'string') {\n            lineBreakStr = lineBreak[0];\n          }\n        } else if (typeof lineBreak[0] === 'string' && typeof lineBreak[1] === 'string') {\n          lineBreakPat = new RegExp(escapeRegExp(lineBreak[0]), 'g');\n          lineBreakStr = lineBreak[1];\n        } else {\n          lineBreak = lineBreak[0];\n        }\n      }\n    }\n\n    if (typeof lineBreak === 'string') {\n      lineBreakStr = lineBreak;\n\n      if (!lineBreakPat) {\n        lineBreakPat = new RegExp(escapeRegExp(lineBreak), 'g');\n      }\n    } else if (lineBreak instanceof RegExp) {\n      lineBreakPat = lineBreak;\n    } else if (!(lineBreak instanceof Array)) {\n      throw new TypeError('lineBreak must be a RegExp object, a string, or an array consisted of a RegExp object and a string');\n    }\n  } // Only assign defaults when `lineBreakPat` is not assigned.\n  // So if `params.lineBreak` is a RegExp, we don't have a value in `lineBreakStr`\n  // yet. We will try to get the value from the input string, and if failed, we\n  // will throw an exception.\n\n\n  if (!lineBreakPat) {\n    lineBreakPat = /\\n/g;\n    lineBreakStr = '\\n';\n  } // Create `multiLineBreakPat` based on `lineBreakPat`, that matches strings\n  // consisted of one or more line breaks and zero or more whitespaces.\n  // Also convert `lineBreakPat` to global if not already so.\n\n\n  flags = 'g';\n\n  if (lineBreakPat.ignoreCase) {\n    flags += 'i';\n  }\n\n  if (lineBreakPat.multiline) {\n    flags += 'm';\n  }\n\n  multiLineBreakPat = new RegExp('\\\\s*(?:' + lineBreakPat.source + ')(?:' + lineBreakPat.source + '|\\\\s)*', flags);\n\n  if (!lineBreakPat.global) {\n    lineBreakPat = new RegExp(lineBreakPat.source, flags);\n  } // Initialize other useful variables.\n\n\n  var re = mode === 'hard' ? /\\b/ : /(\\S+\\s+)/;\n  var prefix = new Array(start + 1).join(' ');\n  var wsStrip = whitespace === 'default' || whitespace === 'collapse',\n      wsCollapse = whitespace === 'collapse',\n      wsLine = whitespace === 'line',\n      wsAll = whitespace === 'all';\n  var tabPat = /\\t/g,\n      collapsePat = /  +/g,\n      pPat = /^\\s+/,\n      tPat = /\\s+$/,\n      nonWsPat = /\\S/,\n      wsPat = /\\s/;\n  var wrapLen = stop - start;\n  return function (text) {\n    text = text.toString().replace(tabPat, tabRepl);\n    var match;\n\n    if (!lineBreakStr) {\n      // Try to get lineBreakStr from `text`\n      lineBreakPat.lastIndex = 0;\n      match = lineBreakPat.exec(text);\n\n      if (match) {\n        lineBreakStr = match[0];\n      } else {\n        throw new TypeError('Line break string for the output not specified');\n      }\n    } // text -> blocks; each bloc -> segments; each segment -> chunks\n\n\n    var blocks,\n        base = 0;\n    var mo, arr, b, res; // Split `text` by line breaks.\n\n    blocks = [];\n    multiLineBreakPat.lastIndex = 0;\n    match = multiLineBreakPat.exec(text);\n\n    while (match) {\n      blocks.push(text.substring(base, match.index));\n\n      if (respectLineBreaks !== 'none') {\n        arr = [];\n        b = 0;\n        lineBreakPat.lastIndex = 0;\n        mo = lineBreakPat.exec(match[0]);\n\n        while (mo) {\n          arr.push(match[0].substring(b, mo.index));\n          b = mo.index + mo[0].length;\n          mo = lineBreakPat.exec(match[0]);\n        }\n\n        arr.push(match[0].substring(b));\n        blocks.push({\n          type: 'break',\n          breaks: arr\n        });\n      } else {\n        // Strip line breaks and insert spaces when necessary.\n        if (wsCollapse) {\n          res = ' ';\n        } else {\n          res = match[0].replace(lineBreakPat, '');\n        }\n\n        blocks.push({\n          type: 'break',\n          remaining: res\n        });\n      }\n\n      base = match.index + match[0].length;\n      match = multiLineBreakPat.exec(text);\n    }\n\n    blocks.push(text.substring(base));\n    var i, j, k;\n    var segments;\n\n    if (skipPat) {\n      segments = [];\n\n      for (i = 0; i < blocks.length; i++) {\n        var bloc = blocks[i];\n\n        if (typeof bloc !== 'string') {\n          // This is an object.\n          segments.push(bloc);\n        } else {\n          base = 0;\n          skipPat.lastIndex = 0;\n          match = skipPat.exec(bloc);\n\n          while (match) {\n            segments.push(bloc.substring(base, match.index));\n            segments.push({\n              type: 'skip',\n              value: match[0]\n            });\n            base = match.index + match[0].length;\n            match = skipPat.exec(bloc);\n          }\n\n          segments.push(bloc.substring(base));\n        }\n      }\n    } else {\n      segments = blocks;\n    }\n\n    var chunks = [];\n\n    for (i = 0; i < segments.length; i++) {\n      var segment = segments[i];\n\n      if (typeof segment !== 'string') {\n        // This is an object.\n        chunks.push(segment);\n      } else {\n        if (wsCollapse) {\n          segment = segment.replace(collapsePat, ' ');\n        }\n\n        var parts = segment.split(re),\n            acc = [];\n\n        for (j = 0; j < parts.length; j++) {\n          var x = parts[j];\n\n          if (mode === 'hard') {\n            for (k = 0; k < x.length; k += wrapLen) {\n              acc.push(x.slice(k, k + wrapLen));\n            }\n          } else {\n            acc.push(x);\n          }\n        }\n\n        chunks = chunks.concat(acc);\n      }\n    }\n\n    var curLine = 0,\n        curLineLength = start + preservedLinePrefix.length,\n        lines = [prefix + preservedLinePrefix],\n        // Holds the \"real length\" (excluding trailing whitespaces) of the\n    // current line if it exceeds `stop`, otherwise 0.\n    // ONLY USED when `wsAll` is true, in `finishOffCurLine()`.\n    bulge = 0,\n        // `cleanLine` is true iff we are at the beginning of an output line. By\n    // \"beginning\" we mean it doesn't contain any non-whitespace char yet.\n    // But its `curLineLength` can be greater than `start`, or even possibly\n    // be greater than `stop`, if `wsStrip` is false.\n    //\n    // Note that a \"clean\" line can still contain skip strings, in addition\n    // to whitespaces.\n    //\n    // This variable is used to allow us strip preceding whitespaces when\n    // `wsStrip` is true, or `wsLine` is true and `preservedLine` is false.\n    cleanLine = true,\n        // `preservedLine` is true iff we are in a preserved input line.\n    //\n    // It's used when `wsLine` is true to (combined with `cleanLine`) decide\n    // whether a whitespace is at the beginning of a preserved input line and\n    // should not be stripped.\n    preservedLine = true,\n        // The current indent prefix for wrapped lines.\n    wrapLinePrefix = wrapLineInitPrefix,\n        remnant; // Always returns '' if `beforeHardBreak` is true.\n    //\n    // Assumption: Each call of this function is always followed by a `lines.push()` call.\n    //\n    // This function can change the status of `cleanLine`, but we don't modify the value of\n    // `cleanLine` in this function. It's fine because `cleanLine` will be set to the correct\n    // value after the `lines.push()` call following this function call. We also don't update\n    // `curLineLength` when pushing a new line and it's safe for the same reason.\n\n    function finishOffCurLine(beforeHardBreak) {\n      var str = lines[curLine],\n          idx,\n          ln,\n          rBase;\n\n      if (!wsAll) {\n        // Strip all trailing whitespaces past `start`.\n        idx = str.length - 1;\n\n        while (idx >= start && str[idx] === ' ') {\n          idx--;\n        }\n\n        while (idx >= start && wsPat.test(str[idx])) {\n          idx--;\n        }\n\n        idx++;\n\n        if (idx !== str.length) {\n          lines[curLine] = str.substring(0, idx);\n        }\n\n        if (preservedLine && cleanLine && wsLine && curLineLength > stop) {\n          // Add the remnants to the next line, just like when `wsAll` is true.\n          rBase = str.length - (curLineLength - stop);\n\n          if (rBase < idx) {\n            // We didn't reach `stop` when stripping due to a bulge.\n            rBase = idx;\n          }\n        }\n      } else {\n        // Strip trailing whitespaces exceeding stop.\n        if (curLineLength > stop) {\n          bulge = bulge || stop;\n          rBase = str.length - (curLineLength - bulge);\n          lines[curLine] = str.substring(0, rBase);\n        }\n\n        bulge = 0;\n      } // Bug: the current implementation of `wrapLineIndent` is buggy: we are not\n      // taking the extra space occupied by the additional indentation into account\n      // when wrapping the line. For example, in \"hard\" mode, we should hard-wrap\n      // long words at `wrapLen - wrapLinePrefix.length` instead of `wrapLen`\n      // and remnants should also be wrapped at `wrapLen - wrapLinePrefix.length`.\n\n\n      if (preservedLine) {\n        // This is a preserved line, and the next output line isn't a\n        // preserved line.\n        preservedLine = false;\n\n        if (wrapLineIndentPat) {\n          idx = lines[curLine].substring(start).search(wrapLineIndentPat);\n\n          if (idx >= 0 && idx + wrapLineIndent > 0) {\n            wrapLinePrefix = new Array(idx + wrapLineIndent + 1).join(' ');\n          } else {\n            wrapLinePrefix = '';\n          }\n        }\n      } // Some remnants are left to the next line.\n\n\n      if (rBase) {\n        while (rBase + wrapLen < str.length) {\n          if (wsAll) {\n            ln = str.substring(rBase, rBase + wrapLen);\n            lines.push(prefix + wrapLinePrefix + ln);\n          } else {\n            lines.push(prefix + wrapLinePrefix);\n          }\n\n          rBase += wrapLen;\n          curLine++;\n        }\n\n        if (beforeHardBreak) {\n          if (wsAll) {\n            ln = str.substring(rBase);\n            lines.push(prefix + wrapLinePrefix + ln);\n          } else {\n            lines.push(prefix + wrapLinePrefix);\n          }\n\n          curLine++;\n        } else {\n          ln = str.substring(rBase);\n          return wrapLinePrefix + ln;\n        }\n      }\n\n      return '';\n    }\n\n    for (i = 0; i < chunks.length; i++) {\n      var chunk = chunks[i];\n\n      if (chunk === '') {\n        continue;\n      }\n\n      if (typeof chunk !== 'string') {\n        if (chunk.type === 'break') {\n          // This is one or more line breaks.\n          // Each entry in `breaks` is just zero or more whitespaces.\n          if (respectLineBreaks !== 'none') {\n            // Note that if `whitespace` is \"collapse\", we still need\n            // to collapse whitespaces in entries of `breaks`.\n            var breaks = chunk.breaks;\n            var num = breaks.length - 1;\n\n            if (respectLineBreaks === 's') {\n              // This is the most complex scenario. We have to check\n              // the line breaks one by one.\n              for (j = 0; j < num; j++) {\n                if (breaks[j + 1].length < respectNum) {\n                  // This line break should be stripped.\n                  if (wsCollapse) {\n                    breaks[j + 1] = ' ';\n                  } else {\n                    breaks[j + 1] = breaks[j] + breaks[j + 1];\n                  }\n                } else {\n                  // This line break should be preserved.\n                  // First finish off the current line.\n                  if (wsAll) {\n                    lines[curLine] += breaks[j];\n                    curLineLength += breaks[j].length;\n                  }\n\n                  finishOffCurLine(true);\n                  lines.push(prefix + preservedLinePrefix);\n                  curLine++;\n                  curLineLength = start + preservedLinePrefix.length;\n                  preservedLine = cleanLine = true;\n                }\n              } // We are adding to either the existing line (if no line break\n              // is qualified for preservance) or a \"new\" line.\n\n\n              if (!cleanLine || wsAll || wsLine && preservedLine) {\n                if (wsCollapse || !cleanLine && breaks[num] === '') {\n                  breaks[num] = ' ';\n                }\n\n                lines[curLine] += breaks[num];\n                curLineLength += breaks[num].length;\n              }\n            } else if (respectLineBreaks === 'm' && num < respectNum) {\n              // These line breaks should be stripped.\n              if (!cleanLine || wsAll || wsLine && preservedLine) {\n                if (wsCollapse) {\n                  chunk = ' ';\n                } else {\n                  chunk = breaks.join('');\n\n                  if (!cleanLine && chunk === '') {\n                    chunk = ' ';\n                  }\n                }\n\n                lines[curLine] += chunk;\n                curLineLength += chunk.length;\n              }\n            } else {\n              // 'all' || ('m' && num >= respectNum)\n              // These line breaks should be preserved.\n              if (wsStrip) {\n                // Finish off the current line.\n                finishOffCurLine(true);\n\n                for (j = 0; j < num; j++) {\n                  lines.push(prefix + preservedLinePrefix);\n                  curLine++;\n                }\n\n                curLineLength = start + preservedLinePrefix.length;\n                preservedLine = cleanLine = true;\n              } else {\n                if (wsAll || preservedLine && cleanLine) {\n                  lines[curLine] += breaks[0];\n                  curLineLength += breaks[0].length;\n                }\n\n                for (j = 0; j < num; j++) {\n                  // Finish off the current line.\n                  finishOffCurLine(true);\n                  lines.push(prefix + preservedLinePrefix + breaks[j + 1]);\n                  curLine++;\n                  curLineLength = start + preservedLinePrefix.length + breaks[j + 1].length;\n                  preservedLine = cleanLine = true;\n                }\n              }\n            }\n          } else {\n            // These line breaks should be stripped.\n            if (!cleanLine || wsAll || wsLine && preservedLine) {\n              chunk = chunk.remaining; // Bug: If `wsAll` is true, `cleanLine` is false, and `chunk`\n              // is '', we insert a space to replace the line break. This\n              // space will be preserved even if we are at the end of an\n              // output line, which is wrong behavior. However, I'm not\n              // sure it's worth it to fix this edge case.\n\n              if (wsCollapse || !cleanLine && chunk === '') {\n                chunk = ' ';\n              }\n\n              lines[curLine] += chunk;\n              curLineLength += chunk.length;\n            }\n          }\n        } else if (chunk.type === 'skip') {\n          // This is a skip string.\n          // Assumption: skip strings don't end with whitespaces.\n          if (curLineLength > stop) {\n            remnant = finishOffCurLine(false);\n            lines.push(prefix + wrapLinePrefix);\n            curLine++;\n            curLineLength = start + wrapLinePrefix.length;\n\n            if (remnant) {\n              lines[curLine] += remnant;\n              curLineLength += remnant.length;\n            }\n\n            cleanLine = true;\n          }\n\n          lines[curLine] += chunk.value;\n        }\n\n        continue;\n      }\n\n      var chunk2;\n\n      while (1) {\n        chunk2 = undefined;\n\n        if (curLineLength + chunk.length > stop && curLineLength + (chunk2 = chunk.replace(tPat, '')).length > stop && chunk2 !== '' && curLineLength > start) {\n          // This line is full, add `chunk` to the next line\n          remnant = finishOffCurLine(false);\n          lines.push(prefix + wrapLinePrefix);\n          curLine++;\n          curLineLength = start + wrapLinePrefix.length;\n\n          if (remnant) {\n            lines[curLine] += remnant;\n            curLineLength += remnant.length;\n            cleanLine = true;\n            continue;\n          }\n\n          if (wsStrip || wsLine && !(preservedLine && cleanLine)) {\n            chunk = chunk.replace(pPat, '');\n          }\n\n          cleanLine = false;\n        } else {\n          // Add `chunk` to this line\n          if (cleanLine) {\n            if (wsStrip || wsLine && !(preservedLine && cleanLine)) {\n              chunk = chunk.replace(pPat, '');\n\n              if (chunk !== '') {\n                cleanLine = false;\n              }\n            } else {\n              if (nonWsPat.test(chunk)) {\n                cleanLine = false;\n              }\n            }\n          }\n        }\n\n        break;\n      }\n\n      if (wsAll && chunk2 && curLineLength + chunk2.length > stop) {\n        bulge = curLineLength + chunk2.length;\n      }\n\n      lines[curLine] += chunk;\n      curLineLength += chunk.length;\n    } // Finally, finish off the last line.\n\n\n    finishOffCurLine(true);\n    return lines.join(lineBreakStr);\n  };\n};\n\nlinewrap.soft = linewrap;\n\nlinewrap.hard = function\n  /*start, stop, params*/\n() {\n  var args = [].slice.call(arguments);\n  var last = args.length - 1;\n\n  if (typeof args[last] === 'object') {\n    args[last].mode = 'hard';\n  } else {\n    args.push({\n      mode: 'hard'\n    });\n  }\n\n  return linewrap.apply(null, args);\n};\n\nlinewrap.wrap = function (text\n/*, start, stop, params*/\n) {\n  var args = [].slice.call(arguments);\n  args.shift();\n  return linewrap.apply(null, args)(text);\n};","map":{"version":3,"sources":["H:/Programming Repositories/Titans/Web/UpSkill.Web/ClientApp/node_modules/@oclif/linewrap/linewrap.js"],"names":["presetMap","skipScheme","lineBreakScheme","whitespace","brPat","lineBreakSchemeMap","skipSchemeMap","modeMap","wsMap","rlbMap","rlbSMPat","escapePat","escapeRegExp","s","replace","linewrap","module","exports","start","stop","params","undefined","preset","mode","tabWidth","skip","lineBreak","respectLineBreaks","respectNum","preservedLineIndent","wrapLineIndent","wrapLineIndentBase","skipPat","lineBreakPat","lineBreakStr","multiLineBreakPat","preservedLinePrefix","wrapLineIndentPat","wrapLineInitPrefix","tabRepl","item","flags","i","Array","length","TypeError","Object","keys","join","parseInt","test","match","exec","isNaN","RegExp","global","ignoreCase","multiline","source","re","prefix","wsStrip","wsCollapse","wsLine","wsAll","tabPat","collapsePat","pPat","tPat","nonWsPat","wsPat","wrapLen","text","toString","lastIndex","blocks","base","mo","arr","b","res","push","substring","index","type","breaks","remaining","j","k","segments","bloc","value","chunks","segment","parts","split","acc","x","slice","concat","curLine","curLineLength","lines","bulge","cleanLine","preservedLine","wrapLinePrefix","remnant","finishOffCurLine","beforeHardBreak","str","idx","ln","rBase","search","chunk","num","chunk2","soft","hard","args","call","arguments","last","apply","wrap","shift"],"mappings":"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","sourcesContent":["// code is originally from https://github.com/AnAppAMonth/linewrap\n\n// Presets\nvar presetMap = {\n  'html': {\n    skipScheme: 'html',\n    lineBreakScheme: 'html',\n    whitespace: 'collapse'\n  }\n}\n\n// lineBreak Schemes\nvar brPat = /<\\s*br(?:[\\s/]*|\\s[^>]*)>/gi\nvar lineBreakSchemeMap = {\n  'unix': [/\\n/g, '\\n'],\n  'dos': [/\\r\\n/g, '\\r\\n'],\n  'mac': [/\\r/g, '\\r'],\n  'html': [brPat, '<br>'],\n  'xhtml': [brPat, '<br/>']\n}\n\n// skip Schemes\nvar skipSchemeMap = {\n  'ansi-color': /\\x1B\\[[^m]*m/g,\n  'html': /<[^>]*>/g,\n  'bbcode': /\\[[^]]*\\]/g\n}\n\nvar modeMap = {\n  'soft': 1,\n  'hard': 1\n}\n\nvar wsMap = {\n  'collapse': 1,\n  'default': 1,\n  'line': 1,\n  'all': 1\n}\n\nvar rlbMap = {\n  'all': 1,\n  'multi': 1,\n  'none': 1\n}\nvar rlbSMPat = /([sm])(\\d+)/\n\nvar escapePat = /[-/\\\\^$*+?.()|[\\]{}]/g\nfunction escapeRegExp (s) {\n  return s.replace(escapePat, '\\\\$&')\n}\n\nvar linewrap = module.exports = function (start, stop, params) {\n  if (typeof start === 'object') {\n    params = start\n    start = params.start\n    stop = params.stop\n  }\n\n  if (typeof stop === 'object') {\n    params = stop\n    start = start || params.start\n    stop = undefined\n  }\n\n  if (!stop) {\n    stop = start\n    start = 0\n  }\n\n  if (!params) { params = {}; }\n  // Supported options and default values.\n  var preset,\n    mode = 'soft',\n    whitespace = 'default',\n    tabWidth = 4,\n    skip, skipScheme, lineBreak, lineBreakScheme,\n    respectLineBreaks = 'all',\n    respectNum,\n    preservedLineIndent,\n    wrapLineIndent, wrapLineIndentBase\n\n  var skipPat\n  var lineBreakPat, lineBreakStr\n  var multiLineBreakPat\n  var preservedLinePrefix = ''\n  var wrapLineIndentPat, wrapLineInitPrefix = ''\n  var tabRepl\n  var item, flags\n  var i\n\n  // First process presets, because these settings can be overwritten later.\n  preset = params.preset\n  if (preset) {\n    if (!(preset instanceof Array)) {\n      preset = [preset]\n    }\n    for (i = 0; i < preset.length; i++) {\n      item = presetMap[preset[i]]\n      if (item) {\n        if (item.mode) {\n          mode = item.mode\n        }\n        if (item.whitespace) {\n          whitespace = item.whitespace\n        }\n        if (item.tabWidth !== undefined) {\n          tabWidth = item.tabWidth\n        }\n        if (item.skip) {\n          skip = item.skip\n        }\n        if (item.skipScheme) {\n          skipScheme = item.skipScheme\n        }\n        if (item.lineBreak) {\n          lineBreak = item.lineBreak\n        }\n        if (item.lineBreakScheme) {\n          lineBreakScheme = item.lineBreakScheme\n        }\n        if (item.respectLineBreaks) {\n          respectLineBreaks = item.respectLineBreaks\n        }\n        if (item.preservedLineIndent !== undefined) {\n          preservedLineIndent = item.preservedLineIndent\n        }\n        if (item.wrapLineIndent !== undefined) {\n          wrapLineIndent = item.wrapLineIndent\n        }\n        if (item.wrapLineIndentBase) {\n          wrapLineIndentBase = item.wrapLineIndentBase\n        }\n      } else {\n        throw new TypeError('preset must be one of \"' + Object.keys(presetMap).join('\", \"') + '\"')\n      }\n    }\n  }\n\n  if (params.mode) {\n    if (modeMap[params.mode]) {\n      mode = params.mode\n    } else {\n      throw new TypeError('mode must be one of \"' + Object.keys(modeMap).join('\", \"') + '\"')\n    }\n  }\n  // Available options: 'collapse', 'default', 'line', and 'all'\n  if (params.whitespace) {\n    if (wsMap[params.whitespace]) {\n      whitespace = params.whitespace\n    } else {\n      throw new TypeError('whitespace must be one of \"' + Object.keys(wsMap).join('\", \"') + '\"')\n    }\n  }\n\n  if (params.tabWidth !== undefined) {\n    if (parseInt(params.tabWidth, 10) >= 0) {\n      tabWidth = parseInt(params.tabWidth, 10)\n    } else {\n      throw new TypeError('tabWidth must be a non-negative integer')\n    }\n  }\n  tabRepl = new Array(tabWidth + 1).join(' ')\n\n  // Available options: 'all', 'multi', 'm\\d+', 's\\d+', 'none'\n  if (params.respectLineBreaks) {\n    if (rlbMap[params.respectLineBreaks] || rlbSMPat.test(params.respectLineBreaks)) {\n      respectLineBreaks = params.respectLineBreaks\n    } else {\n      throw new TypeError('respectLineBreaks must be one of \"' + Object.keys(rlbMap).join('\", \"') +\n        '\", \"m<num>\", \"s<num>\"')\n    }\n  }\n  // After these conversions, now we have 4 options in `respectLineBreaks`:\n  // 'all', 'none', 'm' and 's'.\n  // `respectNum` is applicable iff `respectLineBreaks` is either 'm' or 's'.\n  if (respectLineBreaks === 'multi') {\n    respectLineBreaks = 'm'\n    respectNum = 2\n  } else if (!rlbMap[respectLineBreaks]) {\n    var match = rlbSMPat.exec(respectLineBreaks)\n    respectLineBreaks = match[1]\n    respectNum = parseInt(match[2], 10)\n  }\n\n  if (params.preservedLineIndent !== undefined) {\n    if (parseInt(params.preservedLineIndent, 10) >= 0) {\n      preservedLineIndent = parseInt(params.preservedLineIndent, 10)\n    } else {\n      throw new TypeError('preservedLineIndent must be a non-negative integer')\n    }\n  }\n\n  if (preservedLineIndent > 0) {\n    preservedLinePrefix = new Array(preservedLineIndent + 1).join(' ')\n  }\n\n  if (params.wrapLineIndent !== undefined) {\n    if (!isNaN(parseInt(params.wrapLineIndent, 10))) {\n      wrapLineIndent = parseInt(params.wrapLineIndent, 10)\n    } else {\n      throw new TypeError('wrapLineIndent must be an integer')\n    }\n  }\n  if (params.wrapLineIndentBase) {\n    wrapLineIndentBase = params.wrapLineIndentBase\n  }\n\n  if (wrapLineIndentBase) {\n    if (wrapLineIndent === undefined) {\n      throw new TypeError('wrapLineIndent must be specified when wrapLineIndentBase is specified')\n    }\n    if (wrapLineIndentBase instanceof RegExp) {\n      wrapLineIndentPat = wrapLineIndentBase\n    } else if (typeof wrapLineIndentBase === 'string') {\n      wrapLineIndentPat = new RegExp(escapeRegExp(wrapLineIndentBase))\n    } else {\n      throw new TypeError('wrapLineIndentBase must be either a RegExp object or a string')\n    }\n  } else if (wrapLineIndent > 0) {\n    wrapLineInitPrefix = new Array(wrapLineIndent + 1).join(' ')\n  } else if (wrapLineIndent < 0) {\n    throw new TypeError('wrapLineIndent must be non-negative when a base is not specified')\n  }\n\n  // NOTE: For the two RegExps `skipPat` and `lineBreakPat` that can be specified\n  //       by the user:\n  //       1. We require them to be \"global\", so we have to convert them to global\n  //          if the user specifies a non-global regex.\n  //       2. We cannot call `split()` on them, because they may or may not contain\n  //          capturing parentheses which affect the output of `split()`.\n\n  // Precedence: Regex = Str > Scheme\n  if (params.skipScheme) {\n    if (skipSchemeMap[params.skipScheme]) {\n      skipScheme = params.skipScheme\n    } else {\n      throw new TypeError('skipScheme must be one of \"' + Object.keys(skipSchemeMap).join('\", \"') + '\"')\n    }\n  }\n  if (params.skip) {\n    skip = params.skip\n  }\n\n  if (skip) {\n    if (skip instanceof RegExp) {\n      skipPat = skip\n      if (!skipPat.global) {\n        flags = 'g'\n        if (skipPat.ignoreCase) { flags += 'i'; }\n        if (skipPat.multiline) { flags += 'm'; }\n        skipPat = new RegExp(skipPat.source, flags)\n      }\n    } else if (typeof skip === 'string') {\n      skipPat = new RegExp(escapeRegExp(skip), 'g')\n    } else {\n      throw new TypeError('skip must be either a RegExp object or a string')\n    }\n  }\n  if (!skipPat && skipScheme) {\n    skipPat = skipSchemeMap[skipScheme]\n  }\n\n  // Precedence:\n  // - for lineBreakPat: Regex > Scheme > Str\n  // - for lineBreakStr: Str > Scheme > Regex\n  if (params.lineBreakScheme) {\n    if (lineBreakSchemeMap[params.lineBreakScheme]) {\n      lineBreakScheme = params.lineBreakScheme\n    } else {\n      throw new TypeError('lineBreakScheme must be one of \"' + Object.keys(lineBreakSchemeMap).join('\", \"') + '\"')\n    }\n  }\n  if (params.lineBreak) {\n    lineBreak = params.lineBreak\n  }\n\n  if (lineBreakScheme) {\n    // Supported schemes: 'unix', 'dos', 'mac', 'html', 'xhtml'\n    item = lineBreakSchemeMap[lineBreakScheme]\n    if (item) {\n      lineBreakPat = item[0]\n      lineBreakStr = item[1]\n    }\n  }\n  if (lineBreak) {\n    if (lineBreak instanceof Array) {\n      if (lineBreak.length === 1) {\n        lineBreak = lineBreak[0]\n      } else if (lineBreak.length >= 2) {\n        if (lineBreak[0] instanceof RegExp) {\n          lineBreakPat = lineBreak[0]\n          if (typeof lineBreak[1] === 'string') {\n            lineBreakStr = lineBreak[1]\n          }\n        } else if (lineBreak[1] instanceof RegExp) {\n          lineBreakPat = lineBreak[1]\n          if (typeof lineBreak[0] === 'string') {\n            lineBreakStr = lineBreak[0]\n          }\n        } else if (typeof lineBreak[0] === 'string' && typeof lineBreak[1] === 'string') {\n          lineBreakPat = new RegExp(escapeRegExp(lineBreak[0]), 'g')\n          lineBreakStr = lineBreak[1]\n        } else {\n          lineBreak = lineBreak[0]\n        }\n      }\n    }\n    if (typeof lineBreak === 'string') {\n      lineBreakStr = lineBreak\n      if (!lineBreakPat) {\n        lineBreakPat = new RegExp(escapeRegExp(lineBreak), 'g')\n      }\n    } else if (lineBreak instanceof RegExp) {\n      lineBreakPat = lineBreak\n    } else if (!(lineBreak instanceof Array)) {\n      throw new TypeError('lineBreak must be a RegExp object, a string, or an array consisted of a RegExp object and a string')\n    }\n  }\n  // Only assign defaults when `lineBreakPat` is not assigned.\n  // So if `params.lineBreak` is a RegExp, we don't have a value in `lineBreakStr`\n  // yet. We will try to get the value from the input string, and if failed, we\n  // will throw an exception.\n  if (!lineBreakPat) {\n    lineBreakPat = /\\n/g\n    lineBreakStr = '\\n'\n  }\n\n  // Create `multiLineBreakPat` based on `lineBreakPat`, that matches strings\n  // consisted of one or more line breaks and zero or more whitespaces.\n  // Also convert `lineBreakPat` to global if not already so.\n  flags = 'g'\n  if (lineBreakPat.ignoreCase) { flags += 'i'; }\n  if (lineBreakPat.multiline) { flags += 'm'; }\n  multiLineBreakPat = new RegExp('\\\\s*(?:' + lineBreakPat.source + ')(?:' +\n    lineBreakPat.source + '|\\\\s)*', flags)\n  if (!lineBreakPat.global) {\n    lineBreakPat = new RegExp(lineBreakPat.source, flags)\n  }\n\n  // Initialize other useful variables.\n  var re = mode === 'hard' ? /\\b/ : /(\\S+\\s+)/\n  var prefix = new Array(start + 1).join(' ')\n  var wsStrip = (whitespace === 'default' || whitespace === 'collapse'),\n    wsCollapse = (whitespace === 'collapse'),\n    wsLine = (whitespace === 'line'),\n    wsAll = (whitespace === 'all')\n  var tabPat = /\\t/g,\n    collapsePat = /  +/g,\n    pPat = /^\\s+/,\n    tPat = /\\s+$/,\n    nonWsPat = /\\S/,\n    wsPat = /\\s/\n  var wrapLen = stop - start\n\n  return function (text) {\n    text = text.toString().replace(tabPat, tabRepl)\n\n    var match\n    if (!lineBreakStr) {\n      // Try to get lineBreakStr from `text`\n      lineBreakPat.lastIndex = 0\n      match = lineBreakPat.exec(text)\n      if (match) {\n        lineBreakStr = match[0]\n      } else {\n        throw new TypeError('Line break string for the output not specified')\n      }\n    }\n\n    // text -> blocks; each bloc -> segments; each segment -> chunks\n    var blocks, base = 0\n    var mo, arr, b, res\n    // Split `text` by line breaks.\n    blocks = []\n    multiLineBreakPat.lastIndex = 0\n    match = multiLineBreakPat.exec(text)\n    while(match) {\n      blocks.push(text.substring(base, match.index))\n\n      if (respectLineBreaks !== 'none') {\n        arr = []\n        b = 0\n        lineBreakPat.lastIndex = 0\n        mo = lineBreakPat.exec(match[0])\n        while(mo) {\n          arr.push(match[0].substring(b, mo.index))\n          b = mo.index + mo[0].length\n          mo = lineBreakPat.exec(match[0])\n        }\n        arr.push(match[0].substring(b))\n        blocks.push({type: 'break', breaks: arr})\n      } else {\n        // Strip line breaks and insert spaces when necessary.\n        if (wsCollapse) {\n          res = ' '\n        } else {\n          res = match[0].replace(lineBreakPat, '')\n        }\n        blocks.push({type: 'break', remaining: res})\n      }\n\n      base = match.index + match[0].length\n      match = multiLineBreakPat.exec(text)\n    }\n    blocks.push(text.substring(base))\n\n    var i, j, k\n    var segments\n    if (skipPat) {\n      segments = []\n      for (i = 0; i < blocks.length; i++) {\n        var bloc = blocks[i]\n        if (typeof bloc !== 'string') {\n          // This is an object.\n          segments.push(bloc)\n        } else {\n          base = 0\n          skipPat.lastIndex = 0\n          match = skipPat.exec(bloc)\n          while(match) {\n            segments.push(bloc.substring(base, match.index))\n            segments.push({type: 'skip', value: match[0]})\n            base = match.index + match[0].length\n            match = skipPat.exec(bloc)\n          }\n          segments.push(bloc.substring(base))\n        }\n      }\n    } else {\n      segments = blocks\n    }\n\n    var chunks = []\n    for (i = 0; i < segments.length; i++) {\n      var segment = segments[i]\n      if (typeof segment !== 'string') {\n        // This is an object.\n        chunks.push(segment)\n      } else {\n        if (wsCollapse) {\n          segment = segment.replace(collapsePat, ' ')\n        }\n\n        var parts = segment.split(re),\n          acc = []\n\n        for (j = 0; j < parts.length; j++) {\n          var x = parts[j]\n          if (mode === 'hard') {\n            for (k = 0; k < x.length; k += wrapLen) {\n              acc.push(x.slice(k, k + wrapLen))\n            }\n          } else { acc.push(x); }\n        }\n        chunks = chunks.concat(acc)\n      }\n    }\n\n    var curLine = 0,\n      curLineLength = start + preservedLinePrefix.length,\n      lines = [ prefix + preservedLinePrefix ],\n      // Holds the \"real length\" (excluding trailing whitespaces) of the\n      // current line if it exceeds `stop`, otherwise 0.\n      // ONLY USED when `wsAll` is true, in `finishOffCurLine()`.\n      bulge = 0,\n      // `cleanLine` is true iff we are at the beginning of an output line. By\n      // \"beginning\" we mean it doesn't contain any non-whitespace char yet.\n      // But its `curLineLength` can be greater than `start`, or even possibly\n      // be greater than `stop`, if `wsStrip` is false.\n      //\n      // Note that a \"clean\" line can still contain skip strings, in addition\n      // to whitespaces.\n      //\n      // This variable is used to allow us strip preceding whitespaces when\n      // `wsStrip` is true, or `wsLine` is true and `preservedLine` is false.\n      cleanLine = true,\n      // `preservedLine` is true iff we are in a preserved input line.\n      //\n      // It's used when `wsLine` is true to (combined with `cleanLine`) decide\n      // whether a whitespace is at the beginning of a preserved input line and\n      // should not be stripped.\n      preservedLine = true,\n      // The current indent prefix for wrapped lines.\n      wrapLinePrefix = wrapLineInitPrefix,\n      remnant\n\n    // Always returns '' if `beforeHardBreak` is true.\n    //\n    // Assumption: Each call of this function is always followed by a `lines.push()` call.\n    //\n    // This function can change the status of `cleanLine`, but we don't modify the value of\n    // `cleanLine` in this function. It's fine because `cleanLine` will be set to the correct\n    // value after the `lines.push()` call following this function call. We also don't update\n    // `curLineLength` when pushing a new line and it's safe for the same reason.\n    function finishOffCurLine (beforeHardBreak) {\n      var str = lines[curLine],\n        idx, ln, rBase\n\n      if (!wsAll) {\n        // Strip all trailing whitespaces past `start`.\n        idx = str.length - 1\n        while (idx >= start && str[idx] === ' ') { idx--; }\n        while (idx >= start && wsPat.test(str[idx])) { idx--; }\n        idx++\n\n        if (idx !== str.length) {\n          lines[curLine] = str.substring(0, idx)\n        }\n\n        if (preservedLine && cleanLine && wsLine && curLineLength > stop) {\n          // Add the remnants to the next line, just like when `wsAll` is true.\n          rBase = str.length - (curLineLength - stop)\n          if (rBase < idx) {\n            // We didn't reach `stop` when stripping due to a bulge.\n            rBase = idx\n          }\n        }\n      } else {\n        // Strip trailing whitespaces exceeding stop.\n        if (curLineLength > stop) {\n          bulge = bulge || stop\n          rBase = str.length - (curLineLength - bulge)\n          lines[curLine] = str.substring(0, rBase)\n        }\n        bulge = 0\n      }\n\n      // Bug: the current implementation of `wrapLineIndent` is buggy: we are not\n      // taking the extra space occupied by the additional indentation into account\n      // when wrapping the line. For example, in \"hard\" mode, we should hard-wrap\n      // long words at `wrapLen - wrapLinePrefix.length` instead of `wrapLen`\n      // and remnants should also be wrapped at `wrapLen - wrapLinePrefix.length`.\n      if (preservedLine) {\n        // This is a preserved line, and the next output line isn't a\n        // preserved line.\n        preservedLine = false\n        if (wrapLineIndentPat) {\n          idx = lines[curLine].substring(start).search(wrapLineIndentPat)\n          if (idx >= 0 && idx + wrapLineIndent > 0) {\n            wrapLinePrefix = new Array(idx + wrapLineIndent + 1).join(' ')\n          } else {\n            wrapLinePrefix = ''\n          }\n        }\n      }\n\n      // Some remnants are left to the next line.\n      if (rBase) {\n        while (rBase + wrapLen < str.length) {\n          if (wsAll) {\n            ln = str.substring(rBase, rBase + wrapLen)\n            lines.push(prefix + wrapLinePrefix + ln)\n          } else {\n            lines.push(prefix + wrapLinePrefix)\n          }\n          rBase += wrapLen\n          curLine++\n        }\n        if (beforeHardBreak) {\n          if (wsAll) {\n            ln = str.substring(rBase)\n            lines.push(prefix + wrapLinePrefix + ln)\n          } else {\n            lines.push(prefix + wrapLinePrefix)\n          }\n          curLine++\n        } else {\n          ln = str.substring(rBase)\n          return wrapLinePrefix + ln\n        }\n      }\n\n      return ''\n    }\n\n    for (i = 0; i < chunks.length; i++) {\n      var chunk = chunks[i]\n\n      if (chunk === '') { continue; }\n\n      if (typeof chunk !== 'string') {\n        if (chunk.type === 'break') {\n          // This is one or more line breaks.\n          // Each entry in `breaks` is just zero or more whitespaces.\n          if (respectLineBreaks !== 'none') {\n            // Note that if `whitespace` is \"collapse\", we still need\n            // to collapse whitespaces in entries of `breaks`.\n            var breaks = chunk.breaks\n            var num = breaks.length - 1\n\n            if (respectLineBreaks === 's') {\n              // This is the most complex scenario. We have to check\n              // the line breaks one by one.\n              for (j = 0; j < num; j++) {\n                if (breaks[j + 1].length < respectNum) {\n                  // This line break should be stripped.\n                  if (wsCollapse) {\n                    breaks[j + 1] = ' '\n                  } else {\n                    breaks[j + 1] = breaks[j] + breaks[j + 1]\n                  }\n                } else {\n                  // This line break should be preserved.\n                  // First finish off the current line.\n                  if (wsAll) {\n                    lines[curLine] += breaks[j]\n                    curLineLength += breaks[j].length\n                  }\n                  finishOffCurLine(true)\n\n                  lines.push(prefix + preservedLinePrefix)\n                  curLine++\n                  curLineLength = start + preservedLinePrefix.length\n\n                  preservedLine = cleanLine = true\n                }\n              }\n              // We are adding to either the existing line (if no line break\n              // is qualified for preservance) or a \"new\" line.\n              if (!cleanLine || wsAll || (wsLine && preservedLine)) {\n                if (wsCollapse || (!cleanLine && breaks[num] === '')) {\n                  breaks[num] = ' '\n                }\n                lines[curLine] += breaks[num]\n                curLineLength += breaks[num].length\n              }\n            } else if (respectLineBreaks === 'm' && num < respectNum) {\n              // These line breaks should be stripped.\n              if (!cleanLine || wsAll || (wsLine && preservedLine)) {\n                if (wsCollapse) {\n                  chunk = ' '\n                } else {\n                  chunk = breaks.join('')\n                  if (!cleanLine && chunk === '') {\n                    chunk = ' '\n                  }\n                }\n                lines[curLine] += chunk\n                curLineLength += chunk.length\n              }\n            } else { // 'all' || ('m' && num >= respectNum)\n              // These line breaks should be preserved.\n              if (wsStrip) {\n                // Finish off the current line.\n                finishOffCurLine(true)\n\n                for (j = 0; j < num; j++) {\n                  lines.push(prefix + preservedLinePrefix)\n                  curLine++\n                }\n\n                curLineLength = start + preservedLinePrefix.length\n                preservedLine = cleanLine = true\n              } else {\n                if (wsAll || (preservedLine && cleanLine)) {\n                  lines[curLine] += breaks[0]\n                  curLineLength += breaks[0].length\n                }\n\n                for (j = 0; j < num; j++) {\n                  // Finish off the current line.\n                  finishOffCurLine(true)\n\n                  lines.push(prefix + preservedLinePrefix + breaks[j + 1])\n                  curLine++\n                  curLineLength = start + preservedLinePrefix.length + breaks[j + 1].length\n\n                  preservedLine = cleanLine = true\n                }\n              }\n            }\n          } else {\n            // These line breaks should be stripped.\n            if (!cleanLine || wsAll || (wsLine && preservedLine)) {\n              chunk = chunk.remaining\n\n              // Bug: If `wsAll` is true, `cleanLine` is false, and `chunk`\n              // is '', we insert a space to replace the line break. This\n              // space will be preserved even if we are at the end of an\n              // output line, which is wrong behavior. However, I'm not\n              // sure it's worth it to fix this edge case.\n              if (wsCollapse || (!cleanLine && chunk === '')) {\n                chunk = ' '\n              }\n              lines[curLine] += chunk\n              curLineLength += chunk.length\n            }\n          }\n        } else if (chunk.type === 'skip') {\n          // This is a skip string.\n          // Assumption: skip strings don't end with whitespaces.\n          if (curLineLength > stop) {\n            remnant = finishOffCurLine(false)\n\n            lines.push(prefix + wrapLinePrefix)\n            curLine++\n            curLineLength = start + wrapLinePrefix.length\n\n            if (remnant) {\n              lines[curLine] += remnant\n              curLineLength += remnant.length\n            }\n\n            cleanLine = true\n          }\n          lines[curLine] += chunk.value\n        }\n        continue\n      }\n\n      var chunk2\n      while (1) {\n        chunk2 = undefined\n        if (curLineLength + chunk.length > stop &&\n          curLineLength + (chunk2 = chunk.replace(tPat, '')).length > stop &&\n          chunk2 !== '' &&\n          curLineLength > start) {\n          // This line is full, add `chunk` to the next line\n          remnant = finishOffCurLine(false)\n\n          lines.push(prefix + wrapLinePrefix)\n          curLine++\n          curLineLength = start + wrapLinePrefix.length\n\n          if (remnant) {\n            lines[curLine] += remnant\n            curLineLength += remnant.length\n            cleanLine = true\n            continue\n          }\n\n          if (wsStrip || (wsLine && !(preservedLine && cleanLine))) {\n            chunk = chunk.replace(pPat, '')\n          }\n          cleanLine = false\n        } else {\n          // Add `chunk` to this line\n          if (cleanLine) {\n            if (wsStrip || (wsLine && !(preservedLine && cleanLine))) {\n              chunk = chunk.replace(pPat, '')\n              if (chunk !== '') {\n                cleanLine = false\n              }\n            } else {\n              if (nonWsPat.test(chunk)) {\n                cleanLine = false\n              }\n            }\n          }\n        }\n        break\n      }\n      if (wsAll && chunk2 && curLineLength + chunk2.length > stop) {\n        bulge = curLineLength + chunk2.length\n      }\n      lines[curLine] += chunk\n      curLineLength += chunk.length\n    }\n    // Finally, finish off the last line.\n    finishOffCurLine(true)\n    return lines.join(lineBreakStr)\n  }\n}\n\nlinewrap.soft = linewrap\n\nlinewrap.hard = function ( /*start, stop, params*/) {\n  var args = [].slice.call(arguments)\n  var last = args.length - 1\n  if (typeof args[last] === 'object') {\n    args[last].mode = 'hard'\n  } else {\n    args.push({ mode: 'hard' })\n  }\n  return linewrap.apply(null, args)\n}\n\nlinewrap.wrap = function (text /*, start, stop, params*/) {\n  var args = [].slice.call(arguments)\n  args.shift()\n  return linewrap.apply(null, args)(text)\n}\n\n"]},"metadata":{},"sourceType":"script"}