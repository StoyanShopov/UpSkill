{"ast":null,"code":"'use strict';\n\nvar global = require('../internals/global');\n\nvar isCallable = require('../internals/is-callable');\n\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\n\nvar isForced = require('../internals/is-forced');\n\nvar path = require('../internals/path');\n\nvar bind = require('../internals/function-bind-context');\n\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\n\nvar hasOwn = require('../internals/has-own-property');\n\nvar wrapConstructor = function (NativeConstructor) {\n  var Wrapper = function (a, b, c) {\n    if (this instanceof NativeConstructor) {\n      switch (arguments.length) {\n        case 0:\n          return new NativeConstructor();\n\n        case 1:\n          return new NativeConstructor(a);\n\n        case 2:\n          return new NativeConstructor(a, b);\n      }\n\n      return new NativeConstructor(a, b, c);\n    }\n\n    return NativeConstructor.apply(this, arguments);\n  };\n\n  Wrapper.prototype = NativeConstructor.prototype;\n  return Wrapper;\n};\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n  options.name        - the .name of the function if it does not match the key\n*/\n\n\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var PROTO = options.proto;\n  var nativeSource = GLOBAL ? global : STATIC ? global[TARGET] : (global[TARGET] || {}).prototype;\n  var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];\n  var targetPrototype = target.prototype;\n  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;\n  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;\n\n  for (key in source) {\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contains in native\n\n    USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);\n    targetProperty = target[key];\n    if (USE_NATIVE) if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor(nativeSource, key);\n      nativeProperty = descriptor && descriptor.value;\n    } else nativeProperty = nativeSource[key]; // export native or implementation\n\n    sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];\n    if (USE_NATIVE && typeof targetProperty === typeof sourceProperty) continue; // bind timers to global for call from export context\n\n    if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, global); // wrap global constructors for prevent changs in this version\n    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty); // make static versions for prototype methods\n    else if (PROTO && isCallable(sourceProperty)) resultProperty = bind(Function.call, sourceProperty); // default case\n    else resultProperty = sourceProperty; // add a flag to not completely full polyfills\n\n    if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {\n      createNonEnumerableProperty(resultProperty, 'sham', true);\n    }\n\n    createNonEnumerableProperty(target, key, resultProperty);\n\n    if (PROTO) {\n      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';\n\n      if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {\n        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});\n      } // export virtual prototype methods\n\n\n      createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty); // export real prototype methods\n\n      if (options.real && targetPrototype && !targetPrototype[key]) {\n        createNonEnumerableProperty(targetPrototype, key, sourceProperty);\n      }\n    }\n  }\n};","map":{"version":3,"sources":["H:/Programming Repositories/Titans/Web/UpSkill.Web/ClientApp/node_modules/core-js-pure/internals/export.js"],"names":["global","require","isCallable","getOwnPropertyDescriptor","f","isForced","path","bind","createNonEnumerableProperty","hasOwn","wrapConstructor","NativeConstructor","Wrapper","a","b","c","arguments","length","apply","prototype","module","exports","options","source","TARGET","target","GLOBAL","STATIC","stat","PROTO","proto","nativeSource","targetPrototype","FORCED","USE_NATIVE","VIRTUAL_PROTOTYPE","key","sourceProperty","targetProperty","nativeProperty","resultProperty","descriptor","forced","noTargetGet","value","wrap","Function","call","sham","real"],"mappings":"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","sourcesContent":["'use strict';\nvar global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar isForced = require('../internals/is-forced');\nvar path = require('../internals/path');\nvar bind = require('../internals/function-bind-context');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar hasOwn = require('../internals/has-own-property');\n\nvar wrapConstructor = function (NativeConstructor) {\n  var Wrapper = function (a, b, c) {\n    if (this instanceof NativeConstructor) {\n      switch (arguments.length) {\n        case 0: return new NativeConstructor();\n        case 1: return new NativeConstructor(a);\n        case 2: return new NativeConstructor(a, b);\n      } return new NativeConstructor(a, b, c);\n    } return NativeConstructor.apply(this, arguments);\n  };\n  Wrapper.prototype = NativeConstructor.prototype;\n  return Wrapper;\n};\n\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n  options.name        - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var PROTO = options.proto;\n\n  var nativeSource = GLOBAL ? global : STATIC ? global[TARGET] : (global[TARGET] || {}).prototype;\n\n  var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];\n  var targetPrototype = target.prototype;\n\n  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;\n  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;\n\n  for (key in source) {\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contains in native\n    USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);\n\n    targetProperty = target[key];\n\n    if (USE_NATIVE) if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor(nativeSource, key);\n      nativeProperty = descriptor && descriptor.value;\n    } else nativeProperty = nativeSource[key];\n\n    // export native or implementation\n    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];\n\n    if (USE_NATIVE && typeof targetProperty === typeof sourceProperty) continue;\n\n    // bind timers to global for call from export context\n    if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, global);\n    // wrap global constructors for prevent changs in this version\n    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);\n    // make static versions for prototype methods\n    else if (PROTO && isCallable(sourceProperty)) resultProperty = bind(Function.call, sourceProperty);\n    // default case\n    else resultProperty = sourceProperty;\n\n    // add a flag to not completely full polyfills\n    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(resultProperty, 'sham', true);\n    }\n\n    createNonEnumerableProperty(target, key, resultProperty);\n\n    if (PROTO) {\n      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';\n      if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {\n        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});\n      }\n      // export virtual prototype methods\n      createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty);\n      // export real prototype methods\n      if (options.real && targetPrototype && !targetPrototype[key]) {\n        createNonEnumerableProperty(targetPrototype, key, sourceProperty);\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}