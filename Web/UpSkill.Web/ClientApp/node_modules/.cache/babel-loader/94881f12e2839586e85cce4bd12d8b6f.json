{"ast":null,"code":"import { GraphQLError } from '../../error/GraphQLError';\nimport { Kind } from '../../language/kinds';\nimport { specifiedDirectives } from '../../type/directives';\nexport function duplicateDirectiveMessage(directiveName) {\n  return \"The directive \\\"\".concat(directiveName, \"\\\" can only be used once at this location.\");\n}\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n */\n\nexport function UniqueDirectivesPerLocation(context) {\n  var uniqueDirectiveMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      // Flow can't refine that node.directives will only contain directives,\n      // so we cast so the rest of the code is well typed.\n      var directives = node.directives;\n\n      if (directives) {\n        var knownDirectives = Object.create(null);\n\n        for (var _i6 = 0; _i6 < directives.length; _i6++) {\n          var _directive = directives[_i6];\n          var directiveName = _directive.name.value;\n\n          if (uniqueDirectiveMap[directiveName]) {\n            if (knownDirectives[directiveName]) {\n              context.reportError(new GraphQLError(duplicateDirectiveMessage(directiveName), [knownDirectives[directiveName], _directive]));\n            } else {\n              knownDirectives[directiveName] = _directive;\n            }\n          }\n        }\n      }\n    }\n  };\n}","map":{"version":3,"sources":["H:/Programming Repositories/Titans/Web/UpSkill.Web/ClientApp/node_modules/graphql/validation/rules/UniqueDirectivesPerLocation.mjs"],"names":["GraphQLError","Kind","specifiedDirectives","duplicateDirectiveMessage","directiveName","concat","UniqueDirectivesPerLocation","context","uniqueDirectiveMap","Object","create","schema","getSchema","definedDirectives","getDirectives","_i2","length","directive","name","isRepeatable","astDefinitions","getDocument","definitions","_i4","def","kind","DIRECTIVE_DEFINITION","value","repeatable","enter","node","directives","knownDirectives","_i6","_directive","reportError"],"mappings":"AAAA,SAASA,YAAT,QAA6B,0BAA7B;AACA,SAASC,IAAT,QAAqB,sBAArB;AACA,SAASC,mBAAT,QAAoC,uBAApC;AACA,OAAO,SAASC,yBAAT,CAAmCC,aAAnC,EAAkD;AACvD,SAAO,mBAAmBC,MAAnB,CAA0BD,aAA1B,EAAyC,4CAAzC,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASE,2BAAT,CAAqCC,OAArC,EAA8C;AACnD,MAAIC,kBAAkB,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAzB;AACA,MAAIC,MAAM,GAAGJ,OAAO,CAACK,SAAR,EAAb;AACA,MAAIC,iBAAiB,GAAGF,MAAM,GAAGA,MAAM,CAACG,aAAP,EAAH,GAA4BZ,mBAA1D;;AAEA,OAAK,IAAIa,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGF,iBAAiB,CAACG,MAA1C,EAAkDD,GAAG,EAArD,EAAyD;AACvD,QAAIE,SAAS,GAAGJ,iBAAiB,CAACE,GAAD,CAAjC;AACAP,IAAAA,kBAAkB,CAACS,SAAS,CAACC,IAAX,CAAlB,GAAqC,CAACD,SAAS,CAACE,YAAhD;AACD;;AAED,MAAIC,cAAc,GAAGb,OAAO,CAACc,WAAR,GAAsBC,WAA3C;;AAEA,OAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGH,cAAc,CAACJ,MAAvC,EAA+CO,GAAG,EAAlD,EAAsD;AACpD,QAAIC,GAAG,GAAGJ,cAAc,CAACG,GAAD,CAAxB;;AAEA,QAAIC,GAAG,CAACC,IAAJ,KAAaxB,IAAI,CAACyB,oBAAtB,EAA4C;AAC1ClB,MAAAA,kBAAkB,CAACgB,GAAG,CAACN,IAAJ,CAASS,KAAV,CAAlB,GAAqC,CAACH,GAAG,CAACI,UAA1C;AACD;AACF;;AAED,SAAO;AACL;AACA;AACA;AACAC,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAeC,IAAf,EAAqB;AAC1B;AACA;AACA,UAAIC,UAAU,GAAGD,IAAI,CAACC,UAAtB;;AAEA,UAAIA,UAAJ,EAAgB;AACd,YAAIC,eAAe,GAAGvB,MAAM,CAACC,MAAP,CAAc,IAAd,CAAtB;;AAEA,aAAK,IAAIuB,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGF,UAAU,CAACf,MAAnC,EAA2CiB,GAAG,EAA9C,EAAkD;AAChD,cAAIC,UAAU,GAAGH,UAAU,CAACE,GAAD,CAA3B;AACA,cAAI7B,aAAa,GAAG8B,UAAU,CAAChB,IAAX,CAAgBS,KAApC;;AAEA,cAAInB,kBAAkB,CAACJ,aAAD,CAAtB,EAAuC;AACrC,gBAAI4B,eAAe,CAAC5B,aAAD,CAAnB,EAAoC;AAClCG,cAAAA,OAAO,CAAC4B,WAAR,CAAoB,IAAInC,YAAJ,CAAiBG,yBAAyB,CAACC,aAAD,CAA1C,EAA2D,CAAC4B,eAAe,CAAC5B,aAAD,CAAhB,EAAiC8B,UAAjC,CAA3D,CAApB;AACD,aAFD,MAEO;AACLF,cAAAA,eAAe,CAAC5B,aAAD,CAAf,GAAiC8B,UAAjC;AACD;AACF;AACF;AACF;AACF;AAzBI,GAAP;AA2BD","sourcesContent":["import { GraphQLError } from '../../error/GraphQLError';\nimport { Kind } from '../../language/kinds';\nimport { specifiedDirectives } from '../../type/directives';\nexport function duplicateDirectiveMessage(directiveName) {\n  return \"The directive \\\"\".concat(directiveName, \"\\\" can only be used once at this location.\");\n}\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n */\n\nexport function UniqueDirectivesPerLocation(context) {\n  var uniqueDirectiveMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      // Flow can't refine that node.directives will only contain directives,\n      // so we cast so the rest of the code is well typed.\n      var directives = node.directives;\n\n      if (directives) {\n        var knownDirectives = Object.create(null);\n\n        for (var _i6 = 0; _i6 < directives.length; _i6++) {\n          var _directive = directives[_i6];\n          var directiveName = _directive.name.value;\n\n          if (uniqueDirectiveMap[directiveName]) {\n            if (knownDirectives[directiveName]) {\n              context.reportError(new GraphQLError(duplicateDirectiveMessage(directiveName), [knownDirectives[directiveName], _directive]));\n            } else {\n              knownDirectives[directiveName] = _directive;\n            }\n          }\n        }\n      }\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}