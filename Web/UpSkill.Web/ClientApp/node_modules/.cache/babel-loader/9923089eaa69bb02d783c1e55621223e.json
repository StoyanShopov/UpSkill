{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MatchingEnums = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst isString = val => typeof val === 'string';\n\nfunction isEnumDefinition(node) {\n  return node.kind === graphql_1.Kind.ENUM_TYPE_DEFINITION;\n}\n\nfunction MatchingEnums(context) {\n  const {\n    definitions\n  } = context.getDocument();\n  let definitionsByName = definitions.reduce((typeToDefinitionsMap, node) => {\n    const name = node.name.value;\n\n    if (typeToDefinitionsMap[name]) {\n      typeToDefinitionsMap[name].push(node);\n    } else {\n      typeToDefinitionsMap[name] = [node];\n    }\n\n    return typeToDefinitionsMap;\n  }, {});\n\n  for (const [name, definitions] of Object.entries(definitionsByName)) {\n    if (definitions.every(isEnumDefinition)) {\n      let simpleEnumDefs = [];\n\n      for (const {\n        values,\n        serviceName\n      } of definitions) {\n        if (serviceName && values) simpleEnumDefs.push({\n          serviceName,\n          values: values.map(enumValue => enumValue.name.value)\n        });\n      }\n\n      for (const definition of simpleEnumDefs) {\n        definition.values = definition.values.sort();\n      }\n\n      let matchingEnumGroups = {};\n\n      for (const definition of simpleEnumDefs) {\n        const key = definition.values.join();\n\n        if (matchingEnumGroups[key]) {\n          matchingEnumGroups[key].push(definition.serviceName);\n        } else {\n          matchingEnumGroups[key] = [definition.serviceName];\n        }\n      }\n\n      if (Object.keys(matchingEnumGroups).length > 1) {\n        context.reportError(utils_1.errorWithCode('ENUM_MISMATCH', `The \\`${name}\\` enum does not have identical values in all services. Groups of services with identical values are: ${Object.values(matchingEnumGroups).map(serviceNames => `[${serviceNames.join(', ')}]`).join(', ')}`, definitions));\n      }\n    } else if (definitions.some(isEnumDefinition)) {\n      const servicesWithEnum = definitions.filter(isEnumDefinition).map(definition => definition.serviceName).filter(isString);\n      const servicesWithoutEnum = definitions.filter(d => !isEnumDefinition(d)).map(d => d.serviceName).filter(isString);\n      context.reportError(utils_1.errorWithCode('ENUM_MISMATCH_TYPE', utils_1.logServiceAndType(servicesWithEnum[0], name) + `${name} is an enum in [${servicesWithEnum.join(', ')}], but not in [${servicesWithoutEnum.join(', ')}]`, definitions));\n    }\n  }\n\n  return {};\n}\n\nexports.MatchingEnums = MatchingEnums;","map":{"version":3,"sources":["../../../../src/composition/validate/sdl/matchingEnums.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MatchingEnums = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"../../utils\");\nconst isString = (val) => typeof val === 'string';\nfunction isEnumDefinition(node) {\n    return node.kind === graphql_1.Kind.ENUM_TYPE_DEFINITION;\n}\nfunction MatchingEnums(context) {\n    const { definitions } = context.getDocument();\n    let definitionsByName = definitions.reduce((typeToDefinitionsMap, node) => {\n        const name = node.name.value;\n        if (typeToDefinitionsMap[name]) {\n            typeToDefinitionsMap[name].push(node);\n        }\n        else {\n            typeToDefinitionsMap[name] = [node];\n        }\n        return typeToDefinitionsMap;\n    }, {});\n    for (const [name, definitions] of Object.entries(definitionsByName)) {\n        if (definitions.every(isEnumDefinition)) {\n            let simpleEnumDefs = [];\n            for (const { values, serviceName, } of definitions) {\n                if (serviceName && values)\n                    simpleEnumDefs.push({\n                        serviceName,\n                        values: values.map((enumValue) => enumValue.name.value),\n                    });\n            }\n            for (const definition of simpleEnumDefs) {\n                definition.values = definition.values.sort();\n            }\n            let matchingEnumGroups = {};\n            for (const definition of simpleEnumDefs) {\n                const key = definition.values.join();\n                if (matchingEnumGroups[key]) {\n                    matchingEnumGroups[key].push(definition.serviceName);\n                }\n                else {\n                    matchingEnumGroups[key] = [definition.serviceName];\n                }\n            }\n            if (Object.keys(matchingEnumGroups).length > 1) {\n                context.reportError(utils_1.errorWithCode('ENUM_MISMATCH', `The \\`${name}\\` enum does not have identical values in all services. Groups of services with identical values are: ${Object.values(matchingEnumGroups)\n                    .map(serviceNames => `[${serviceNames.join(', ')}]`)\n                    .join(', ')}`, definitions));\n            }\n        }\n        else if (definitions.some(isEnumDefinition)) {\n            const servicesWithEnum = definitions\n                .filter(isEnumDefinition)\n                .map(definition => definition.serviceName)\n                .filter(isString);\n            const servicesWithoutEnum = definitions\n                .filter(d => !isEnumDefinition(d))\n                .map(d => d.serviceName)\n                .filter(isString);\n            context.reportError(utils_1.errorWithCode('ENUM_MISMATCH_TYPE', utils_1.logServiceAndType(servicesWithEnum[0], name) +\n                `${name} is an enum in [${servicesWithEnum.join(', ')}], but not in [${servicesWithoutEnum.join(', ')}]`, definitions));\n        }\n    }\n    return {};\n}\nexports.MatchingEnums = MatchingEnums;\n//# sourceMappingURL=matchingEnums.js.map"]},"metadata":{},"sourceType":"script"}