{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UniqueFieldDefinitionNames = exports.existedFieldDefinitionNameMessage = exports.duplicateFieldDefinitionNameMessage = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst utils_1 = require(\"../../utils\");\n\nfunction duplicateFieldDefinitionNameMessage(typeName, fieldName) {\n  return `Field \"${typeName}.${fieldName}\" can only be defined once.`;\n}\n\nexports.duplicateFieldDefinitionNameMessage = duplicateFieldDefinitionNameMessage;\n\nfunction existedFieldDefinitionNameMessage(typeName, fieldName, serviceName) {\n  return `${utils_1.logServiceAndType(serviceName, typeName, fieldName)}Field \"${typeName}.${fieldName}\" already exists in the schema. It cannot also be defined in this type extension. If this is meant to be an external field, add the \\`@external\\` directive.`;\n}\n\nexports.existedFieldDefinitionNameMessage = existedFieldDefinitionNameMessage;\n\nfunction UniqueFieldDefinitionNames(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownFieldNames = Object.create(null);\n  const possibleValueTypes = Object.create(null);\n  return {\n    InputObjectTypeExtension: checkFieldUniqueness,\n    InterfaceTypeExtension: checkFieldUniqueness,\n    ObjectTypeExtension: checkFieldUniqueness,\n    InputObjectTypeDefinition: checkFieldUniquenessExcludingValueTypes,\n    InterfaceTypeDefinition: checkFieldUniquenessExcludingValueTypes,\n    ObjectTypeDefinition: checkFieldUniquenessExcludingValueTypes\n  };\n\n  function checkFieldUniqueness(node) {\n    var _a;\n\n    const typeName = node.name.value;\n\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = Object.create(null);\n    }\n\n    if (!node.fields) {\n      return false;\n    }\n\n    const fieldNames = knownFieldNames[typeName];\n\n    for (const fieldDef of node.fields) {\n      const fieldName = fieldDef.name.value;\n\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        const type = existingTypeMap[typeName];\n        context.reportError(new graphql_1.GraphQLError(existedFieldDefinitionNameMessage(typeName, fieldName, (_a = node.serviceName) !== null && _a !== void 0 ? _a : ''), graphql_1.isObjectType(type) || graphql_1.isInterfaceType(type) || graphql_1.isInputObjectType(type) ? type.getFields()[fieldName].astNode : undefined));\n      } else if (fieldNames[fieldName]) {\n        context.reportError(new graphql_1.GraphQLError(duplicateFieldDefinitionNameMessage(typeName, fieldName), [fieldNames[fieldName], fieldDef.name]));\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n\n    return false;\n  }\n\n  function checkFieldUniquenessExcludingValueTypes(node) {\n    const typeName = node.name.value;\n    const valueTypeFromSchema = existingTypeMap[typeName] && existingTypeMap[typeName].astNode;\n    const duplicateTypeNode = valueTypeFromSchema || possibleValueTypes[node.name.value];\n\n    if (duplicateTypeNode) {\n      const {\n        fields,\n        inputValues\n      } = utils_1.diffTypeNodes(node, duplicateTypeNode);\n\n      if (Object.values(fields).every(diffEntry => diffEntry.length === 2)) {\n        return false;\n      }\n\n      const inputValuesTypes = Object.values(inputValues);\n\n      if (inputValuesTypes.length > 0 && inputValuesTypes.every(diffEntry => diffEntry.length === 2)) {\n        return false;\n      }\n    } else {\n      possibleValueTypes[node.name.value] = node;\n    }\n\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = Object.create(null);\n    }\n\n    if (!node.fields) {\n      return false;\n    }\n\n    const fieldNames = knownFieldNames[typeName];\n\n    for (const fieldDef of node.fields) {\n      const fieldName = fieldDef.name.value;\n\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        context.reportError(new graphql_1.GraphQLError(existedFieldDefinitionNameMessage(typeName, fieldName, existingTypeMap[typeName].astNode.serviceName), fieldDef.name));\n      } else if (fieldNames[fieldName]) {\n        context.reportError(new graphql_1.GraphQLError(duplicateFieldDefinitionNameMessage(typeName, fieldName), [fieldNames[fieldName], fieldDef.name]));\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n\nexports.UniqueFieldDefinitionNames = UniqueFieldDefinitionNames;\n\nfunction hasField(type, fieldName) {\n  if (graphql_1.isObjectType(type) || graphql_1.isInterfaceType(type) || graphql_1.isInputObjectType(type)) {\n    return Boolean(type.getFields()[fieldName]);\n  }\n\n  return false;\n}","map":{"version":3,"sources":["../../../../src/composition/validate/sdl/uniqueFieldDefinitionNames.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UniqueFieldDefinitionNames = exports.existedFieldDefinitionNameMessage = exports.duplicateFieldDefinitionNameMessage = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"../../utils\");\nfunction duplicateFieldDefinitionNameMessage(typeName, fieldName) {\n    return `Field \"${typeName}.${fieldName}\" can only be defined once.`;\n}\nexports.duplicateFieldDefinitionNameMessage = duplicateFieldDefinitionNameMessage;\nfunction existedFieldDefinitionNameMessage(typeName, fieldName, serviceName) {\n    return `${utils_1.logServiceAndType(serviceName, typeName, fieldName)}Field \"${typeName}.${fieldName}\" already exists in the schema. It cannot also be defined in this type extension. If this is meant to be an external field, add the \\`@external\\` directive.`;\n}\nexports.existedFieldDefinitionNameMessage = existedFieldDefinitionNameMessage;\nfunction UniqueFieldDefinitionNames(context) {\n    const schema = context.getSchema();\n    const existingTypeMap = schema\n        ? schema.getTypeMap()\n        : Object.create(null);\n    const knownFieldNames = Object.create(null);\n    const possibleValueTypes = Object.create(null);\n    return {\n        InputObjectTypeExtension: checkFieldUniqueness,\n        InterfaceTypeExtension: checkFieldUniqueness,\n        ObjectTypeExtension: checkFieldUniqueness,\n        InputObjectTypeDefinition: checkFieldUniquenessExcludingValueTypes,\n        InterfaceTypeDefinition: checkFieldUniquenessExcludingValueTypes,\n        ObjectTypeDefinition: checkFieldUniquenessExcludingValueTypes,\n    };\n    function checkFieldUniqueness(node) {\n        var _a;\n        const typeName = node.name.value;\n        if (!knownFieldNames[typeName]) {\n            knownFieldNames[typeName] = Object.create(null);\n        }\n        if (!node.fields) {\n            return false;\n        }\n        const fieldNames = knownFieldNames[typeName];\n        for (const fieldDef of node.fields) {\n            const fieldName = fieldDef.name.value;\n            if (hasField(existingTypeMap[typeName], fieldName)) {\n                const type = existingTypeMap[typeName];\n                context.reportError(new graphql_1.GraphQLError(existedFieldDefinitionNameMessage(typeName, fieldName, (_a = node.serviceName) !== null && _a !== void 0 ? _a : ''), graphql_1.isObjectType(type) || graphql_1.isInterfaceType(type) || graphql_1.isInputObjectType(type) ?\n                    type.getFields()[fieldName].astNode : undefined));\n            }\n            else if (fieldNames[fieldName]) {\n                context.reportError(new graphql_1.GraphQLError(duplicateFieldDefinitionNameMessage(typeName, fieldName), [fieldNames[fieldName], fieldDef.name]));\n            }\n            else {\n                fieldNames[fieldName] = fieldDef.name;\n            }\n        }\n        return false;\n    }\n    function checkFieldUniquenessExcludingValueTypes(node) {\n        const typeName = node.name.value;\n        const valueTypeFromSchema = existingTypeMap[typeName] &&\n            existingTypeMap[typeName].astNode;\n        const duplicateTypeNode = valueTypeFromSchema || possibleValueTypes[node.name.value];\n        if (duplicateTypeNode) {\n            const { fields, inputValues } = utils_1.diffTypeNodes(node, duplicateTypeNode);\n            if (Object.values(fields).every(diffEntry => diffEntry.length === 2)) {\n                return false;\n            }\n            const inputValuesTypes = Object.values(inputValues);\n            if (inputValuesTypes.length > 0 &&\n                inputValuesTypes.every((diffEntry) => diffEntry.length === 2)) {\n                return false;\n            }\n        }\n        else {\n            possibleValueTypes[node.name.value] = node;\n        }\n        if (!knownFieldNames[typeName]) {\n            knownFieldNames[typeName] = Object.create(null);\n        }\n        if (!node.fields) {\n            return false;\n        }\n        const fieldNames = knownFieldNames[typeName];\n        for (const fieldDef of node.fields) {\n            const fieldName = fieldDef.name.value;\n            if (hasField(existingTypeMap[typeName], fieldName)) {\n                context.reportError(new graphql_1.GraphQLError(existedFieldDefinitionNameMessage(typeName, fieldName, existingTypeMap[typeName].astNode.serviceName), fieldDef.name));\n            }\n            else if (fieldNames[fieldName]) {\n                context.reportError(new graphql_1.GraphQLError(duplicateFieldDefinitionNameMessage(typeName, fieldName), [fieldNames[fieldName], fieldDef.name]));\n            }\n            else {\n                fieldNames[fieldName] = fieldDef.name;\n            }\n        }\n        return false;\n    }\n}\nexports.UniqueFieldDefinitionNames = UniqueFieldDefinitionNames;\nfunction hasField(type, fieldName) {\n    if (graphql_1.isObjectType(type) || graphql_1.isInterfaceType(type) || graphql_1.isInputObjectType(type)) {\n        return Boolean(type.getFields()[fieldName]);\n    }\n    return false;\n}\n//# sourceMappingURL=uniqueFieldDefinitionNames.js.map"]},"metadata":{},"sourceType":"script"}