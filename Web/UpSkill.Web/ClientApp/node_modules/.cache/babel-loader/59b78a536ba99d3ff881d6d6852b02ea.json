{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport flatMap from '../polyfills/flatMap';\nimport objectValues from '../polyfills/objectValues';\nimport inspect from '../jsutils/inspect';\nimport mapValue from '../jsutils/mapValue';\nimport invariant from '../jsutils/invariant';\nimport devAssert from '../jsutils/devAssert';\nimport keyValMap from '../jsutils/keyValMap';\nimport { Kind } from '../language/kinds';\nimport { isTypeDefinitionNode, isTypeExtensionNode } from '../language/predicates';\nimport { assertValidSDLExtension } from '../validation/validate';\nimport { GraphQLDirective } from '../type/directives';\nimport { isSpecifiedScalarType } from '../type/scalars';\nimport { isIntrospectionType } from '../type/introspection';\nimport { assertSchema, GraphQLSchema } from '../type/schema';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from '../type/definition';\nimport { ASTDefinitionBuilder } from './buildASTSchema';\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  documentAST && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST');\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDLExtension(documentAST, schema);\n  } // Collect the type definitions and extensions found in the document.\n\n\n  var typeDefs = [];\n  var typeExtsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefs = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExts = [];\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExts.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      var extendedTypeName = def.name.value;\n      var existingTypeExts = typeExtsMap[extendedTypeName];\n      typeExtsMap[extendedTypeName] = existingTypeExts ? existingTypeExts.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExts.length === 0 && !schemaDef) {\n    return schema;\n  }\n\n  var schemaConfig = schema.toConfig();\n  var astBuilder = new ASTDefinitionBuilder(options, function (typeName) {\n    var type = typeMap[typeName];\n\n    if (type === undefined) {\n      throw new Error(\"Unknown type: \\\"\".concat(typeName, \"\\\".\"));\n    }\n\n    return type;\n  });\n  var typeMap = keyValMap(typeDefs, function (node) {\n    return node.name.value;\n  }, function (node) {\n    return astBuilder.buildType(node);\n  });\n\n  for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types; _i4 < _schemaConfig$types2.length; _i4++) {\n    var existingType = _schemaConfig$types2[_i4];\n    typeMap[existingType.name] = extendNamedType(existingType);\n  } // Get the extended root operation types.\n\n\n  var operationTypes = {\n    query: schemaConfig.query && schemaConfig.query.name,\n    mutation: schemaConfig.mutation && schemaConfig.mutation.name,\n    subscription: schemaConfig.subscription && schemaConfig.subscription.name\n  };\n\n  if (schemaDef) {\n    for (var _i6 = 0, _schemaDef$operationT2 = schemaDef.operationTypes; _i6 < _schemaDef$operationT2.length; _i6++) {\n      var _ref2 = _schemaDef$operationT2[_i6];\n      var operation = _ref2.operation;\n      var type = _ref2.type;\n      operationTypes[operation] = type.name.value;\n    }\n  } // Then, incorporate schema definition and all schema extensions.\n\n\n  for (var _i8 = 0; _i8 < schemaExts.length; _i8++) {\n    var schemaExt = schemaExts[_i8];\n\n    if (schemaExt.operationTypes) {\n      for (var _i10 = 0, _schemaExt$operationT2 = schemaExt.operationTypes; _i10 < _schemaExt$operationT2.length; _i10++) {\n        var _ref4 = _schemaExt$operationT2[_i10];\n        var _operation = _ref4.operation;\n        var _type = _ref4.type;\n        operationTypes[_operation] = _type.name.value;\n      }\n    }\n  } // Support both original legacy names and extended legacy names.\n\n\n  var allowedLegacyNames = schemaConfig.allowedLegacyNames.concat(options && options.allowedLegacyNames || []); // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    query: getMaybeTypeByName(operationTypes.query),\n    mutation: getMaybeTypeByName(operationTypes.mutation),\n    subscription: getMaybeTypeByName(operationTypes.subscription),\n    types: objectValues(typeMap),\n    directives: getMergedDirectives(),\n    astNode: schemaDef || schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExts),\n    allowedLegacyNames: allowedLegacyNames\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      return new GraphQLList(replaceType(type.ofType));\n    } else if (isNonNullType(type)) {\n      return new GraphQLNonNull(replaceType(type.ofType));\n    }\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    return typeMap[type.name];\n  }\n\n  function getMaybeTypeByName(typeName) {\n    return typeName ? typeMap[typeName] : null;\n  }\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives().map(extendDirective);\n    existingDirectives || devAssert(0, 'schema must have default directives');\n    return existingDirectives.concat(directiveDefs.map(function (node) {\n      return astBuilder.buildDirective(node);\n    }));\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    } else if (isScalarType(type)) {\n      return extendScalarType(type);\n    } else if (isObjectType(type)) {\n      return extendObjectType(type);\n    } else if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    } else if (isUnionType(type)) {\n      return extendUnionType(type);\n    } else if (isEnumType(type)) {\n      return extendEnumType(type);\n    } else if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    } // Not reachable. All possible types have been considered.\n\n    /* istanbul ignore next */\n\n\n    invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n\n  function extendDirective(directive) {\n    var config = directive.toConfig();\n    return new GraphQLDirective(_objectSpread({}, config, {\n      args: mapValue(config.args, extendArg)\n    }));\n  }\n\n  function extendInputObjectType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var fieldNodes = flatMap(extensions, function (node) {\n      return node.fields || [];\n    });\n    return new GraphQLInputObjectType(_objectSpread({}, config, {\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, function (field) {\n          return _objectSpread({}, field, {\n            type: replaceType(field.type)\n          });\n        }), {}, keyValMap(fieldNodes, function (field) {\n          return field.name.value;\n        }, function (field) {\n          return astBuilder.buildInputField(field);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendEnumType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[type.name] || [];\n    var valueNodes = flatMap(extensions, function (node) {\n      return node.values || [];\n    });\n    return new GraphQLEnumType(_objectSpread({}, config, {\n      values: _objectSpread({}, config.values, {}, keyValMap(valueNodes, function (value) {\n        return value.name.value;\n      }, function (value) {\n        return astBuilder.buildEnumValue(value);\n      })),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendScalarType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    return new GraphQLScalarType(_objectSpread({}, config, {\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendObjectType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var interfaceNodes = flatMap(extensions, function (node) {\n      return node.interfaces || [];\n    });\n    var fieldNodes = flatMap(extensions, function (node) {\n      return node.fields || [];\n    });\n    return new GraphQLObjectType(_objectSpread({}, config, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), interfaceNodes.map(function (node) {\n          return astBuilder.getNamedType(node);\n        }));\n      },\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, extendField), {}, keyValMap(fieldNodes, function (node) {\n          return node.name.value;\n        }, function (node) {\n          return astBuilder.buildField(node);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendInterfaceType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var fieldNodes = flatMap(extensions, function (node) {\n      return node.fields || [];\n    });\n    return new GraphQLInterfaceType(_objectSpread({}, config, {\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, extendField), {}, keyValMap(fieldNodes, function (node) {\n          return node.name.value;\n        }, function (node) {\n          return astBuilder.buildField(node);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendUnionType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var typeNodes = flatMap(extensions, function (node) {\n      return node.types || [];\n    });\n    return new GraphQLUnionType(_objectSpread({}, config, {\n      types: function types() {\n        return [].concat(type.getTypes().map(replaceNamedType), typeNodes.map(function (node) {\n          return astBuilder.getNamedType(node);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendField(field) {\n    return _objectSpread({}, field, {\n      type: replaceType(field.type),\n      args: mapValue(field.args, extendArg)\n    });\n  }\n\n  function extendArg(arg) {\n    return _objectSpread({}, arg, {\n      type: replaceType(arg.type)\n    });\n  }\n}","map":{"version":3,"sources":["H:/Programming Repositories/Titans/Web/UpSkill.Web/ClientApp/node_modules/graphql/utilities/extendSchema.mjs"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","flatMap","objectValues","inspect","mapValue","invariant","devAssert","keyValMap","Kind","isTypeDefinitionNode","isTypeExtensionNode","assertValidSDLExtension","GraphQLDirective","isSpecifiedScalarType","isIntrospectionType","assertSchema","GraphQLSchema","isScalarType","isObjectType","isInterfaceType","isUnionType","isListType","isNonNullType","isEnumType","isInputObjectType","GraphQLList","GraphQLNonNull","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","ASTDefinitionBuilder","extendSchema","schema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","typeDefs","typeExtsMap","create","directiveDefs","schemaDef","schemaExts","_i2","_documentAST$definiti2","definitions","def","SCHEMA_DEFINITION","SCHEMA_EXTENSION","extendedTypeName","name","existingTypeExts","concat","DIRECTIVE_DEFINITION","schemaConfig","toConfig","astBuilder","typeName","type","typeMap","undefined","Error","node","buildType","_i4","_schemaConfig$types2","types","existingType","extendNamedType","operationTypes","query","mutation","subscription","_i6","_schemaDef$operationT2","_ref2","operation","_i8","schemaExt","_i10","_schemaExt$operationT2","_ref4","_operation","_type","allowedLegacyNames","getMaybeTypeByName","directives","getMergedDirectives","astNode","extensionASTNodes","replaceType","ofType","replaceNamedType","existingDirectives","getDirectives","map","extendDirective","buildDirective","extendScalarType","extendObjectType","extendInterfaceType","extendUnionType","extendEnumType","extendInputObjectType","directive","config","args","extendArg","extensions","fieldNodes","fields","field","buildInputField","valueNodes","values","buildEnumValue","interfaceNodes","interfaces","getInterfaces","getNamedType","extendField","buildField","typeNodes","getTypes","arg"],"mappings":"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","sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport flatMap from '../polyfills/flatMap';\nimport objectValues from '../polyfills/objectValues';\nimport inspect from '../jsutils/inspect';\nimport mapValue from '../jsutils/mapValue';\nimport invariant from '../jsutils/invariant';\nimport devAssert from '../jsutils/devAssert';\nimport keyValMap from '../jsutils/keyValMap';\nimport { Kind } from '../language/kinds';\nimport { isTypeDefinitionNode, isTypeExtensionNode } from '../language/predicates';\nimport { assertValidSDLExtension } from '../validation/validate';\nimport { GraphQLDirective } from '../type/directives';\nimport { isSpecifiedScalarType } from '../type/scalars';\nimport { isIntrospectionType } from '../type/introspection';\nimport { assertSchema, GraphQLSchema } from '../type/schema';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from '../type/definition';\nimport { ASTDefinitionBuilder } from './buildASTSchema';\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  documentAST && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST');\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDLExtension(documentAST, schema);\n  } // Collect the type definitions and extensions found in the document.\n\n\n  var typeDefs = [];\n  var typeExtsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefs = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExts = [];\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExts.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      var extendedTypeName = def.name.value;\n      var existingTypeExts = typeExtsMap[extendedTypeName];\n      typeExtsMap[extendedTypeName] = existingTypeExts ? existingTypeExts.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExts.length === 0 && !schemaDef) {\n    return schema;\n  }\n\n  var schemaConfig = schema.toConfig();\n  var astBuilder = new ASTDefinitionBuilder(options, function (typeName) {\n    var type = typeMap[typeName];\n\n    if (type === undefined) {\n      throw new Error(\"Unknown type: \\\"\".concat(typeName, \"\\\".\"));\n    }\n\n    return type;\n  });\n  var typeMap = keyValMap(typeDefs, function (node) {\n    return node.name.value;\n  }, function (node) {\n    return astBuilder.buildType(node);\n  });\n\n  for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types; _i4 < _schemaConfig$types2.length; _i4++) {\n    var existingType = _schemaConfig$types2[_i4];\n    typeMap[existingType.name] = extendNamedType(existingType);\n  } // Get the extended root operation types.\n\n\n  var operationTypes = {\n    query: schemaConfig.query && schemaConfig.query.name,\n    mutation: schemaConfig.mutation && schemaConfig.mutation.name,\n    subscription: schemaConfig.subscription && schemaConfig.subscription.name\n  };\n\n  if (schemaDef) {\n    for (var _i6 = 0, _schemaDef$operationT2 = schemaDef.operationTypes; _i6 < _schemaDef$operationT2.length; _i6++) {\n      var _ref2 = _schemaDef$operationT2[_i6];\n      var operation = _ref2.operation;\n      var type = _ref2.type;\n      operationTypes[operation] = type.name.value;\n    }\n  } // Then, incorporate schema definition and all schema extensions.\n\n\n  for (var _i8 = 0; _i8 < schemaExts.length; _i8++) {\n    var schemaExt = schemaExts[_i8];\n\n    if (schemaExt.operationTypes) {\n      for (var _i10 = 0, _schemaExt$operationT2 = schemaExt.operationTypes; _i10 < _schemaExt$operationT2.length; _i10++) {\n        var _ref4 = _schemaExt$operationT2[_i10];\n        var _operation = _ref4.operation;\n        var _type = _ref4.type;\n        operationTypes[_operation] = _type.name.value;\n      }\n    }\n  } // Support both original legacy names and extended legacy names.\n\n\n  var allowedLegacyNames = schemaConfig.allowedLegacyNames.concat(options && options.allowedLegacyNames || []); // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    query: getMaybeTypeByName(operationTypes.query),\n    mutation: getMaybeTypeByName(operationTypes.mutation),\n    subscription: getMaybeTypeByName(operationTypes.subscription),\n    types: objectValues(typeMap),\n    directives: getMergedDirectives(),\n    astNode: schemaDef || schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExts),\n    allowedLegacyNames: allowedLegacyNames\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      return new GraphQLList(replaceType(type.ofType));\n    } else if (isNonNullType(type)) {\n      return new GraphQLNonNull(replaceType(type.ofType));\n    }\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    return typeMap[type.name];\n  }\n\n  function getMaybeTypeByName(typeName) {\n    return typeName ? typeMap[typeName] : null;\n  }\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives().map(extendDirective);\n    existingDirectives || devAssert(0, 'schema must have default directives');\n    return existingDirectives.concat(directiveDefs.map(function (node) {\n      return astBuilder.buildDirective(node);\n    }));\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    } else if (isScalarType(type)) {\n      return extendScalarType(type);\n    } else if (isObjectType(type)) {\n      return extendObjectType(type);\n    } else if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    } else if (isUnionType(type)) {\n      return extendUnionType(type);\n    } else if (isEnumType(type)) {\n      return extendEnumType(type);\n    } else if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    } // Not reachable. All possible types have been considered.\n\n\n    /* istanbul ignore next */\n    invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n\n  function extendDirective(directive) {\n    var config = directive.toConfig();\n    return new GraphQLDirective(_objectSpread({}, config, {\n      args: mapValue(config.args, extendArg)\n    }));\n  }\n\n  function extendInputObjectType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var fieldNodes = flatMap(extensions, function (node) {\n      return node.fields || [];\n    });\n    return new GraphQLInputObjectType(_objectSpread({}, config, {\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, function (field) {\n          return _objectSpread({}, field, {\n            type: replaceType(field.type)\n          });\n        }), {}, keyValMap(fieldNodes, function (field) {\n          return field.name.value;\n        }, function (field) {\n          return astBuilder.buildInputField(field);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendEnumType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[type.name] || [];\n    var valueNodes = flatMap(extensions, function (node) {\n      return node.values || [];\n    });\n    return new GraphQLEnumType(_objectSpread({}, config, {\n      values: _objectSpread({}, config.values, {}, keyValMap(valueNodes, function (value) {\n        return value.name.value;\n      }, function (value) {\n        return astBuilder.buildEnumValue(value);\n      })),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendScalarType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    return new GraphQLScalarType(_objectSpread({}, config, {\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendObjectType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var interfaceNodes = flatMap(extensions, function (node) {\n      return node.interfaces || [];\n    });\n    var fieldNodes = flatMap(extensions, function (node) {\n      return node.fields || [];\n    });\n    return new GraphQLObjectType(_objectSpread({}, config, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), interfaceNodes.map(function (node) {\n          return astBuilder.getNamedType(node);\n        }));\n      },\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, extendField), {}, keyValMap(fieldNodes, function (node) {\n          return node.name.value;\n        }, function (node) {\n          return astBuilder.buildField(node);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendInterfaceType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var fieldNodes = flatMap(extensions, function (node) {\n      return node.fields || [];\n    });\n    return new GraphQLInterfaceType(_objectSpread({}, config, {\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, extendField), {}, keyValMap(fieldNodes, function (node) {\n          return node.name.value;\n        }, function (node) {\n          return astBuilder.buildField(node);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendUnionType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var typeNodes = flatMap(extensions, function (node) {\n      return node.types || [];\n    });\n    return new GraphQLUnionType(_objectSpread({}, config, {\n      types: function types() {\n        return [].concat(type.getTypes().map(replaceNamedType), typeNodes.map(function (node) {\n          return astBuilder.getNamedType(node);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendField(field) {\n    return _objectSpread({}, field, {\n      type: replaceType(field.type),\n      args: mapValue(field.args, extendArg)\n    });\n  }\n\n  function extendArg(arg) {\n    return _objectSpread({}, arg, {\n      type: replaceType(arg.type)\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}