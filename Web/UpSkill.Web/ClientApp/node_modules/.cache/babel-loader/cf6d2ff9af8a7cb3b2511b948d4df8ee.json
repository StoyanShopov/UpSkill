{"ast":null,"code":"'use strict';\n\nconst {\n  constants: BufferConstants\n} = require('buffer');\n\nconst stream = require('stream');\n\nconst {\n  promisify\n} = require('util');\n\nconst bufferStream = require('./buffer-stream');\n\nconst streamPipelinePromisified = promisify(stream.pipeline);\n\nclass MaxBufferError extends Error {\n  constructor() {\n    super('maxBuffer exceeded');\n    this.name = 'MaxBufferError';\n  }\n\n}\n\nasync function getStream(inputStream, options) {\n  if (!inputStream) {\n    throw new Error('Expected a stream');\n  }\n\n  options = {\n    maxBuffer: Infinity,\n    ...options\n  };\n  const {\n    maxBuffer\n  } = options;\n  const stream = bufferStream(options);\n  await new Promise((resolve, reject) => {\n    const rejectPromise = error => {\n      // Don't retrieve an oversized buffer.\n      if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {\n        error.bufferedData = stream.getBufferedValue();\n      }\n\n      reject(error);\n    };\n\n    (async () => {\n      try {\n        await streamPipelinePromisified(inputStream, stream);\n        resolve();\n      } catch (error) {\n        rejectPromise(error);\n      }\n    })();\n\n    stream.on('data', () => {\n      if (stream.getBufferedLength() > maxBuffer) {\n        rejectPromise(new MaxBufferError());\n      }\n    });\n  });\n  return stream.getBufferedValue();\n}\n\nmodule.exports = getStream;\n\nmodule.exports.buffer = (stream, options) => getStream(stream, { ...options,\n  encoding: 'buffer'\n});\n\nmodule.exports.array = (stream, options) => getStream(stream, { ...options,\n  array: true\n});\n\nmodule.exports.MaxBufferError = MaxBufferError;","map":{"version":3,"sources":["H:/Programming Repositories/Titans/Web/UpSkill.Web/ClientApp/node_modules/env-ci/node_modules/get-stream/index.js"],"names":["constants","BufferConstants","require","stream","promisify","bufferStream","streamPipelinePromisified","pipeline","MaxBufferError","Error","constructor","name","getStream","inputStream","options","maxBuffer","Infinity","Promise","resolve","reject","rejectPromise","error","getBufferedLength","MAX_LENGTH","bufferedData","getBufferedValue","on","module","exports","buffer","encoding","array"],"mappings":"AAAA;;AACA,MAAM;AAACA,EAAAA,SAAS,EAAEC;AAAZ,IAA+BC,OAAO,CAAC,QAAD,CAA5C;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAM;AAACE,EAAAA;AAAD,IAAcF,OAAO,CAAC,MAAD,CAA3B;;AACA,MAAMG,YAAY,GAAGH,OAAO,CAAC,iBAAD,CAA5B;;AAEA,MAAMI,yBAAyB,GAAGF,SAAS,CAACD,MAAM,CAACI,QAAR,CAA3C;;AAEA,MAAMC,cAAN,SAA6BC,KAA7B,CAAmC;AAClCC,EAAAA,WAAW,GAAG;AACb,UAAM,oBAAN;AACA,SAAKC,IAAL,GAAY,gBAAZ;AACA;;AAJiC;;AAOnC,eAAeC,SAAf,CAAyBC,WAAzB,EAAsCC,OAAtC,EAA+C;AAC9C,MAAI,CAACD,WAAL,EAAkB;AACjB,UAAM,IAAIJ,KAAJ,CAAU,mBAAV,CAAN;AACA;;AAEDK,EAAAA,OAAO,GAAG;AACTC,IAAAA,SAAS,EAAEC,QADF;AAET,OAAGF;AAFM,GAAV;AAKA,QAAM;AAACC,IAAAA;AAAD,MAAcD,OAApB;AACA,QAAMX,MAAM,GAAGE,YAAY,CAACS,OAAD,CAA3B;AAEA,QAAM,IAAIG,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,UAAMC,aAAa,GAAGC,KAAK,IAAI;AAC9B;AACA,UAAIA,KAAK,IAAIlB,MAAM,CAACmB,iBAAP,MAA8BrB,eAAe,CAACsB,UAA3D,EAAuE;AACtEF,QAAAA,KAAK,CAACG,YAAN,GAAqBrB,MAAM,CAACsB,gBAAP,EAArB;AACA;;AAEDN,MAAAA,MAAM,CAACE,KAAD,CAAN;AACA,KAPD;;AASA,KAAC,YAAY;AACZ,UAAI;AACH,cAAMf,yBAAyB,CAACO,WAAD,EAAcV,MAAd,CAA/B;AACAe,QAAAA,OAAO;AACP,OAHD,CAGE,OAAOG,KAAP,EAAc;AACfD,QAAAA,aAAa,CAACC,KAAD,CAAb;AACA;AACD,KAPD;;AASAlB,IAAAA,MAAM,CAACuB,EAAP,CAAU,MAAV,EAAkB,MAAM;AACvB,UAAIvB,MAAM,CAACmB,iBAAP,KAA6BP,SAAjC,EAA4C;AAC3CK,QAAAA,aAAa,CAAC,IAAIZ,cAAJ,EAAD,CAAb;AACA;AACD,KAJD;AAKA,GAxBK,CAAN;AA0BA,SAAOL,MAAM,CAACsB,gBAAP,EAAP;AACA;;AAEDE,MAAM,CAACC,OAAP,GAAiBhB,SAAjB;;AACAe,MAAM,CAACC,OAAP,CAAeC,MAAf,GAAwB,CAAC1B,MAAD,EAASW,OAAT,KAAqBF,SAAS,CAACT,MAAD,EAAS,EAAC,GAAGW,OAAJ;AAAagB,EAAAA,QAAQ,EAAE;AAAvB,CAAT,CAAtD;;AACAH,MAAM,CAACC,OAAP,CAAeG,KAAf,GAAuB,CAAC5B,MAAD,EAASW,OAAT,KAAqBF,SAAS,CAACT,MAAD,EAAS,EAAC,GAAGW,OAAJ;AAAaiB,EAAAA,KAAK,EAAE;AAApB,CAAT,CAArD;;AACAJ,MAAM,CAACC,OAAP,CAAepB,cAAf,GAAgCA,cAAhC","sourcesContent":["'use strict';\nconst {constants: BufferConstants} = require('buffer');\nconst stream = require('stream');\nconst {promisify} = require('util');\nconst bufferStream = require('./buffer-stream');\n\nconst streamPipelinePromisified = promisify(stream.pipeline);\n\nclass MaxBufferError extends Error {\n\tconstructor() {\n\t\tsuper('maxBuffer exceeded');\n\t\tthis.name = 'MaxBufferError';\n\t}\n}\n\nasync function getStream(inputStream, options) {\n\tif (!inputStream) {\n\t\tthrow new Error('Expected a stream');\n\t}\n\n\toptions = {\n\t\tmaxBuffer: Infinity,\n\t\t...options\n\t};\n\n\tconst {maxBuffer} = options;\n\tconst stream = bufferStream(options);\n\n\tawait new Promise((resolve, reject) => {\n\t\tconst rejectPromise = error => {\n\t\t\t// Don't retrieve an oversized buffer.\n\t\t\tif (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {\n\t\t\t\terror.bufferedData = stream.getBufferedValue();\n\t\t\t}\n\n\t\t\treject(error);\n\t\t};\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tawait streamPipelinePromisified(inputStream, stream);\n\t\t\t\tresolve();\n\t\t\t} catch (error) {\n\t\t\t\trejectPromise(error);\n\t\t\t}\n\t\t})();\n\n\t\tstream.on('data', () => {\n\t\t\tif (stream.getBufferedLength() > maxBuffer) {\n\t\t\t\trejectPromise(new MaxBufferError());\n\t\t\t}\n\t\t});\n\t});\n\n\treturn stream.getBufferedValue();\n}\n\nmodule.exports = getStream;\nmodule.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});\nmodule.exports.array = (stream, options) => getStream(stream, {...options, array: true});\nmodule.exports.MaxBufferError = MaxBufferError;\n"]},"metadata":{},"sourceType":"script"}