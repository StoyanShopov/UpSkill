{"ast":null,"code":"'use strict';\n\nconst normalizeArgs = (file, args = []) => {\n  if (!Array.isArray(args)) {\n    return [file];\n  }\n\n  return [file, ...args];\n};\n\nconst NO_ESCAPE_REGEXP = /^[\\w.-]+$/;\nconst DOUBLE_QUOTES_REGEXP = /\"/g;\n\nconst escapeArg = arg => {\n  if (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {\n    return arg;\n  }\n\n  return `\"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\\\\"')}\"`;\n};\n\nconst joinCommand = (file, args) => {\n  return normalizeArgs(file, args).join(' ');\n};\n\nconst getEscapedCommand = (file, args) => {\n  return normalizeArgs(file, args).map(arg => escapeArg(arg)).join(' ');\n};\n\nconst SPACES_REGEXP = / +/g; // Handle `execa.command()`\n\nconst parseCommand = command => {\n  const tokens = [];\n\n  for (const token of command.trim().split(SPACES_REGEXP)) {\n    // Allow spaces to be escaped by a backslash if not meant as a delimiter\n    const previousToken = tokens[tokens.length - 1];\n\n    if (previousToken && previousToken.endsWith('\\\\')) {\n      // Merge previous token with current one\n      tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;\n    } else {\n      tokens.push(token);\n    }\n  }\n\n  return tokens;\n};\n\nmodule.exports = {\n  joinCommand,\n  getEscapedCommand,\n  parseCommand\n};","map":{"version":3,"sources":["H:/Programming Repositories/Titans/Web/UpSkill.Web/ClientApp/node_modules/env-ci/node_modules/execa/lib/command.js"],"names":["normalizeArgs","file","args","Array","isArray","NO_ESCAPE_REGEXP","DOUBLE_QUOTES_REGEXP","escapeArg","arg","test","replace","joinCommand","join","getEscapedCommand","map","SPACES_REGEXP","parseCommand","command","tokens","token","trim","split","previousToken","length","endsWith","slice","push","module","exports"],"mappings":"AAAA;;AACA,MAAMA,aAAa,GAAG,CAACC,IAAD,EAAOC,IAAI,GAAG,EAAd,KAAqB;AAC1C,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAL,EAA0B;AACzB,WAAO,CAACD,IAAD,CAAP;AACA;;AAED,SAAO,CAACA,IAAD,EAAO,GAAGC,IAAV,CAAP;AACA,CAND;;AAQA,MAAMG,gBAAgB,GAAG,WAAzB;AACA,MAAMC,oBAAoB,GAAG,IAA7B;;AAEA,MAAMC,SAAS,GAAGC,GAAG,IAAI;AACxB,MAAI,OAAOA,GAAP,KAAe,QAAf,IAA2BH,gBAAgB,CAACI,IAAjB,CAAsBD,GAAtB,CAA/B,EAA2D;AAC1D,WAAOA,GAAP;AACA;;AAED,SAAQ,IAAGA,GAAG,CAACE,OAAJ,CAAYJ,oBAAZ,EAAkC,KAAlC,CAAyC,GAApD;AACA,CAND;;AAQA,MAAMK,WAAW,GAAG,CAACV,IAAD,EAAOC,IAAP,KAAgB;AACnC,SAAOF,aAAa,CAACC,IAAD,EAAOC,IAAP,CAAb,CAA0BU,IAA1B,CAA+B,GAA/B,CAAP;AACA,CAFD;;AAIA,MAAMC,iBAAiB,GAAG,CAACZ,IAAD,EAAOC,IAAP,KAAgB;AACzC,SAAOF,aAAa,CAACC,IAAD,EAAOC,IAAP,CAAb,CAA0BY,GAA1B,CAA8BN,GAAG,IAAID,SAAS,CAACC,GAAD,CAA9C,EAAqDI,IAArD,CAA0D,GAA1D,CAAP;AACA,CAFD;;AAIA,MAAMG,aAAa,GAAG,KAAtB,C,CAEA;;AACA,MAAMC,YAAY,GAAGC,OAAO,IAAI;AAC/B,QAAMC,MAAM,GAAG,EAAf;;AACA,OAAK,MAAMC,KAAX,IAAoBF,OAAO,CAACG,IAAR,GAAeC,KAAf,CAAqBN,aAArB,CAApB,EAAyD;AACxD;AACA,UAAMO,aAAa,GAAGJ,MAAM,CAACA,MAAM,CAACK,MAAP,GAAgB,CAAjB,CAA5B;;AACA,QAAID,aAAa,IAAIA,aAAa,CAACE,QAAd,CAAuB,IAAvB,CAArB,EAAmD;AAClD;AACAN,MAAAA,MAAM,CAACA,MAAM,CAACK,MAAP,GAAgB,CAAjB,CAAN,GAA6B,GAAED,aAAa,CAACG,KAAd,CAAoB,CAApB,EAAuB,CAAC,CAAxB,CAA2B,IAAGN,KAAM,EAAnE;AACA,KAHD,MAGO;AACND,MAAAA,MAAM,CAACQ,IAAP,CAAYP,KAAZ;AACA;AACD;;AAED,SAAOD,MAAP;AACA,CAdD;;AAgBAS,MAAM,CAACC,OAAP,GAAiB;AAChBjB,EAAAA,WADgB;AAEhBE,EAAAA,iBAFgB;AAGhBG,EAAAA;AAHgB,CAAjB","sourcesContent":["'use strict';\nconst normalizeArgs = (file, args = []) => {\n\tif (!Array.isArray(args)) {\n\t\treturn [file];\n\t}\n\n\treturn [file, ...args];\n};\n\nconst NO_ESCAPE_REGEXP = /^[\\w.-]+$/;\nconst DOUBLE_QUOTES_REGEXP = /\"/g;\n\nconst escapeArg = arg => {\n\tif (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {\n\t\treturn arg;\n\t}\n\n\treturn `\"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\\\\"')}\"`;\n};\n\nconst joinCommand = (file, args) => {\n\treturn normalizeArgs(file, args).join(' ');\n};\n\nconst getEscapedCommand = (file, args) => {\n\treturn normalizeArgs(file, args).map(arg => escapeArg(arg)).join(' ');\n};\n\nconst SPACES_REGEXP = / +/g;\n\n// Handle `execa.command()`\nconst parseCommand = command => {\n\tconst tokens = [];\n\tfor (const token of command.trim().split(SPACES_REGEXP)) {\n\t\t// Allow spaces to be escaped by a backslash if not meant as a delimiter\n\t\tconst previousToken = tokens[tokens.length - 1];\n\t\tif (previousToken && previousToken.endsWith('\\\\')) {\n\t\t\t// Merge previous token with current one\n\t\t\ttokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;\n\t\t} else {\n\t\t\ttokens.push(token);\n\t\t}\n\t}\n\n\treturn tokens;\n};\n\nmodule.exports = {\n\tjoinCommand,\n\tgetEscapedCommand,\n\tparseCommand\n};\n"]},"metadata":{},"sourceType":"script"}