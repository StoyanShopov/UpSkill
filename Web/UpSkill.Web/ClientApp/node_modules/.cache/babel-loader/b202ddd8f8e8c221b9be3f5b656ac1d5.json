{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst indent = require(\"indent-string\");\n\nconst stripAnsi = require(\"strip-ansi\");\n\nconst width = require('string-width');\n\nconst wrap = require('wrap-ansi');\n\nconst widestLine = require('widest-line');\n\nfunction renderList(input, opts) {\n  if (input.length === 0) {\n    return '';\n  }\n\n  const renderMultiline = () => {\n    let output = '';\n\n    for (let [left, right] of input) {\n      if (!left && !right) continue;\n\n      if (left) {\n        if (opts.stripAnsi) left = stripAnsi(left);\n        output += wrap(left.trim(), opts.maxWidth, {\n          hard: true,\n          trim: false\n        });\n      }\n\n      if (right) {\n        if (opts.stripAnsi) right = stripAnsi(right);\n        output += '\\n';\n        output += indent(wrap(right.trim(), opts.maxWidth - 2, {\n          hard: true,\n          trim: false\n        }), 4);\n      }\n\n      output += '\\n\\n';\n    }\n\n    return output.trim();\n  };\n\n  if (opts.multiline) return renderMultiline();\n  const maxLength = widestLine(input.map(i => i[0]).join('\\n'));\n  let output = '';\n  let spacer = opts.spacer || '\\n';\n  let cur = '';\n\n  for (const [left, r] of input) {\n    let right = r;\n\n    if (cur) {\n      output += spacer;\n      output += cur;\n    }\n\n    cur = left || '';\n    if (opts.stripAnsi) cur = stripAnsi(cur);\n\n    if (!right) {\n      cur = cur.trim();\n      continue;\n    }\n\n    if (opts.stripAnsi) right = stripAnsi(right);\n    right = wrap(right.trim(), opts.maxWidth - (maxLength + 2), {\n      hard: true,\n      trim: false\n    }); // right = wrap(right.trim(), screen.stdtermwidth - (maxLength + 4), {hard: true, trim: false})\n\n    const [first, ...lines] = right.split('\\n').map(s => s.trim());\n    cur += ' '.repeat(maxLength - width(cur) + 2);\n    cur += first;\n\n    if (lines.length === 0) {\n      continue;\n    } // if we start putting too many lines down, render in multiline format\n\n\n    if (lines.length > 4) return renderMultiline(); // if spacer is not defined, separate all rows with extra newline\n\n    if (!opts.spacer) spacer = '\\n\\n';\n    cur += '\\n';\n    cur += indent(lines.join('\\n'), maxLength + 2);\n  }\n\n  if (cur) {\n    output += spacer;\n    output += cur;\n  }\n\n  return output.trim();\n}\n\nexports.renderList = renderList;","map":{"version":3,"sources":["H:/Programming Repositories/Titans/Web/UpSkill.Web/ClientApp/node_modules/@oclif/plugin-help/lib/list.js"],"names":["Object","defineProperty","exports","value","indent","require","stripAnsi","width","wrap","widestLine","renderList","input","opts","length","renderMultiline","output","left","right","trim","maxWidth","hard","multiline","maxLength","map","i","join","spacer","cur","r","first","lines","split","s","repeat"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst indent = require(\"indent-string\");\nconst stripAnsi = require(\"strip-ansi\");\nconst width = require('string-width');\nconst wrap = require('wrap-ansi');\nconst widestLine = require('widest-line');\nfunction renderList(input, opts) {\n    if (input.length === 0) {\n        return '';\n    }\n    const renderMultiline = () => {\n        let output = '';\n        for (let [left, right] of input) {\n            if (!left && !right)\n                continue;\n            if (left) {\n                if (opts.stripAnsi)\n                    left = stripAnsi(left);\n                output += wrap(left.trim(), opts.maxWidth, { hard: true, trim: false });\n            }\n            if (right) {\n                if (opts.stripAnsi)\n                    right = stripAnsi(right);\n                output += '\\n';\n                output += indent(wrap(right.trim(), opts.maxWidth - 2, { hard: true, trim: false }), 4);\n            }\n            output += '\\n\\n';\n        }\n        return output.trim();\n    };\n    if (opts.multiline)\n        return renderMultiline();\n    const maxLength = widestLine(input.map(i => i[0]).join('\\n'));\n    let output = '';\n    let spacer = opts.spacer || '\\n';\n    let cur = '';\n    for (const [left, r] of input) {\n        let right = r;\n        if (cur) {\n            output += spacer;\n            output += cur;\n        }\n        cur = left || '';\n        if (opts.stripAnsi)\n            cur = stripAnsi(cur);\n        if (!right) {\n            cur = cur.trim();\n            continue;\n        }\n        if (opts.stripAnsi)\n            right = stripAnsi(right);\n        right = wrap(right.trim(), opts.maxWidth - (maxLength + 2), { hard: true, trim: false });\n        // right = wrap(right.trim(), screen.stdtermwidth - (maxLength + 4), {hard: true, trim: false})\n        const [first, ...lines] = right.split('\\n').map(s => s.trim());\n        cur += ' '.repeat(maxLength - width(cur) + 2);\n        cur += first;\n        if (lines.length === 0) {\n            continue;\n        }\n        // if we start putting too many lines down, render in multiline format\n        if (lines.length > 4)\n            return renderMultiline();\n        // if spacer is not defined, separate all rows with extra newline\n        if (!opts.spacer)\n            spacer = '\\n\\n';\n        cur += '\\n';\n        cur += indent(lines.join('\\n'), maxLength + 2);\n    }\n    if (cur) {\n        output += spacer;\n        output += cur;\n    }\n    return output.trim();\n}\nexports.renderList = renderList;\n"]},"metadata":{},"sourceType":"script"}